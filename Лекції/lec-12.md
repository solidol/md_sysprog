# Обробка файлів за допомогою WinAPI32

## Перелік лекцій


1.  [Склад мови С++](lec-01.md)
2.  [Дані та операції](lec-02.md)
3.  [Організація введення-виведення даних](lec-03.md)
4.  [Основні оператори С++](lec-04.md)
5.  [Масиви у С++](lec-05.md)
6.  [Дані символьного типу](lec-06.md)
7.  [Функції](lec-07.md)
8.  [Дані типу структура](lec-08.md)
9.  [Покажчики у С++](lec-09.md)
10. [Робота з динамічною пам'ятю](lec-10.md)
11. [Робота з файлами](lec-11.md)
12. [Обробка файлів за допомогою WinAPI32](lec-12.md)
13. [Об'єктно-орієнтоване програмування. Класи](lec-13.md)
14. [Методи та властивості. Екземпляри класу](lec-14.md)
15. [Паралельні обчислення за стандартом OpenMP](lec-15.md)
16. [Паралельні обчислення з бібліотекою MPI](lec-16.md)

## Системні бібліотеки WinAPI32



## Створення файлів

Для створення нового або відкриття існуючого файлу використовується функція CreateFile. При використанні функції CreateFile необхідно вказати, передбачається читання або запис в файл або і те й інше. Також необхідно вказати необхідні дії в разі наявності файлу на диску або його відсутності (наприклад, перезаписувати файл, якщо він існує і створювати новий, якщо - ні). Також функція CreateFile дозволяє вказати можливість поділу файлу з іншими додатками (одночасного читання / запису кількох додатків в файл). Якщо деякий додаток монополізував  доступ до файлу на читання і / або запис, то ніяке інше додаток не зможе читати і / або писати в файл, поки перше його ви не вийдете.

Операційна система привласнює кожному відкритого файлу унікальний ідентифікатор (дескриптор, file handle), який може бути використаний при зверненнях до файлу для запису, читання і отримання інформації про фото. Дескриптор дійсний до тих пір, поки файл не закрите. Додаток може успадковувати дескриптори файлів від процесу, який його запустив (якщо дескриптори успадковані).

Функція CreateFile серед інших об'єктів дозволяє звертатися до файлів і каналах (pipes). При зверненні до каналів функція CreateFile дозволяє створювати клієнтське підключення до іменованих каналів, які знаходяться в режимі очікування підключення. Серверна частина каналу створюється функцією CreateNamedPipe. Один додаток може створювати безліч клієнтських підключень до каналу, але до одного екземпляра каналу може підключатися тільки один додаток (Варто зазначити, що можливе існування декількох екземплярів іменованих каналів з однаковими іменами).

Функція CreateFile має наступний прототип:

```cpp
HANDLE CreateFile(
  LPCTSTR lpFileName, // ім'я файлу
  DWORD dwDesiredAccess, // режим доступу
  DWORD dwShareMode, // режим спільного доступу
  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // SD
  DWORD dwCreationDisposition, // як створити
  DWORD dwFlagsAndAttributes, // атрибути файлу
  HANDLE hTemplateFile // обробка  шаблону файлу
);
```



Параметри:

lpFileName:
[in] Покажчик на рядок, що містить ім'я об'єкта для створення або відкриття (ім'я файлу, шлях до файлу, ім'я каналу та ін.). Якщо ім'я задається літеральної константою, то слід помістити її в макрос TEXT () або поставити L перед лапками, які відкриваються. Наприклад,  TEXT("C:\\tmp.txt") або L"C:\\tmp.txt"

dwDesiredAccess:
[in] Опис бажаного режиму доступу до файлу. Існує можливість передачі великої кількості різних прапорів. Нас цікавлять прапори GENERIC_READ, GENERIC_WRITE і їх об'єднання. При доступі до каналів слід враховувати режим створення каналу сервером. Якщо сервер створив канал для запису, то клієнт відкриває його для читання і навпаки. Якщо сервер створив канал для читання і запису, то клієнт може відкрити його як для читання, так і для запису. 

dwShareMode:
[in] Визначає режим поділу об'єкта 
0 – додаток відкриває файл для монопольного доступу. Наступні звернення на відкриття даного файлу будуть безуспішними, поки даних дескриптор не буде закритий. Для поділу доступу до файлу можуть використовуватися такі ключі (один або разом):
FILE_SHARE_READ - дозволені лише наступні операції відкриття тільки на читання.
FILE_SHARE_WRITE - дозволені лише наступні операції відкриття тільки на запис. 
lpSecurityAttributes 
[in] Покажчик на сруктуру SECURITY_ATTRIBUTES, яка визначає можливість успадкування дескриптора дочірніми процесами. Можна передавати NULL - це значить, що дескриптор не може бути успадкований (для наших додатків цього достатньо).

dwCreationDisposition:
[in] Визначає те, які дії необхідно зробити у випадках, якщо файл існує і якщо файл не існує. Цей параметр повинен мати одне з наступних заначень:
Значення Пояснення
CREATE_NEW Створює файл. Виклик закінчується невдачею, якщо файл існує.
CREATE_ALWAYS Створює новий файл. Якщо файл існує, то його вміст і атрибути будуть стерті.
OPEN_EXISTING Відкриття файлу. Якщо файл не існує, то виклик закінчиться невдачею.
OPEN_ALWAYS Відкриває файл. Якщо файл не існує, то він буде створений.
TRUNCATE_EXISTING Відкриває файл, розмір якого обнуляється. Файл повинен відкриватися як мінімум з режимом доступу GENERIC_WRITE. Якщо файл не існує, то виклик буде невдалий.

dwFlagsAndAttributes:
[in] Дозволяє задавати файлові атрибути (тільки для читання, прихований, системний та ін.). Також дозволяє повідомляти операційній системі бажану поведінку при роботі з файлами. Наприклад, запис в файл без буферизації (FILE_FLAG_NO_BUFFERING і FILE_FLAG_WRITE_THROUGH); оптимізація для невпорядкованого доступу (FILE_FLAG_RANDOM_ACCESS); відкриття для асинхронного введення / виводу (FILE_FLAG_OVERLAPPED). 

Значення, що повертається:
Якщо виклик успішний, повертається дескриптор відкритого файлу. Якщо виклик невдалий, повертається константа INVALID_HANDLE_VALUE. Код помилки можна отримати викликом функції GetLastError. Детальну інформацію про помилку (по її коду) можна отримати викликом функції FormatMessage.

## Копіювання файлів

Для копіювання файлів використовується функція CopyFile:

```cpp
BOOL CopyFile(
  LPCTSTR lpExistingFileName, // ім'я існуючого файлу 
  LPCTSTR lpNewFileName, // ім'я нового файлу
  BOOL bFailIfExists // дію, якщо файл існує TRUE - помилка
  // FALSE - перезаписувати
);
```


При вдалому завершенні повертає ненульове значення.

## Переміщення файлів

Для перейменування файлів і директорій використовується функція MoveFile:

```cpp
BOOL MoveFile(
  LPCTSTR lpExistingFileName, // имя файла
  LPCTSTR lpNewFileName // новое имя файла
);
```
    

При вдалому завершенні повертає ненульове значення.

## Видалення файлів

Для видалення існуючих файлів використовується функція DeleteFile:


```cpp
BOOL DeleteFile(
  LPCTSTR lpFileName // имя удаляемого файла
);
```


При вдалому завершенні повертає ненульове значення.

## Читання та записування


Читання / запис в файл:
Кожен відкритий файл має файловий покажчик (file pointer), який вказує позицію наступного файлу, який буде записаний / прочитаний. При відкритті файлу його файловий покажчик переміщається на початок файлу. Після прочитання / запису чергового файлу система переміщує файловий вказівник. Файловий покажчик можна переміщувати, використовуючи функцію SetFilePointer.
Для читання / запису в файл використовуються функції ReadFile і WriteFile, при цьому необхідно, щоб файл був відкритий на читання і на запис відповідно.


## Читання з файлу

Функція ReadFile читає з файлу вказану кількість символів, починаючи з позиції, позначеної файловим покажчиком. При синхронному (на противагу асинхронного) читанні файловий покажчик зсувається на фактично прочитану кількість байт.

```cpp
BOOL ReadFile(
  HANDLE hFile, // дескриптор файлу
  LPVOID lpBuffer, // буфер даних
  DWORD nNumberOfBytesToRead, // кількість байт для прочитання
  LPDWORD lpNumberOfBytesRead, // кількість фактично прочитаних байт
  LPOVERLAPPED lpOverlapped // покажчик на структуру, яка використовується під час
  // асинхронному читанні
);
```


Параметри:

hFile:
[in] Дескриптор читаного файлу. Повинен бути відкритий з доступом GENERIC_READ.

lpBuffer:
[out] Покажчик на буфер, який приймає дані з файлу. 

nNumberOfBytesToRead:
[in] Задає кількість байт, які необхідно прочитати з файлу.

lpNumberOfBytesRead:
[out] Покажчик на змінну, яка приймає кількість реально прочитаних байтів.

lpOverlapped:
[in] Покажчик на структуру OVERLAPPED. При не асинхронному доступі слід передавати NULL.

Значення, що повертається:
Якщо виконання функції сталося успішно, то повертається ненульове значення. Якщо повернуто нульове значення, але прочитано 0 байт, значить файловий покажчик стояв на кінці файлу перед операцією читання.


## Запис у файл


Функція WriteFile записує в файл дані, починаючи з позиції, позначеної файловим покажчиком. При синхронної (на противагу асинхронного) записи файловий покажчик зсувається на фактично записане 
кількість байт.


```cpp
BOOL WriteFile(
  HANDLE hFile, // дескриптор файлу
  LPCVOID lpBuffer, // буфер даних
  DWORD nNumberOfBytesToWrite, // кількість байт для запису
  LPDWORD lpNumberOfBytesWritten,// кількість фактично записаних байт
  LPOVERLAPPED lpOverlapped // покажчик на структуру, яка використовується під час
  // асинхронному читанні
);
```

Параметри:

hFile:
[in] Дескриптор файлу, в який проводиться запис. Повинен бути відкритий з доступом GENERIC_WRITE.

lpBuffer:
[in] Покажчик на буфер, що містить дані, які необхідно записати. 

nNumberOfBytesToWrite:
[in] Задає кількість байт, які необхідно записати в файл.

lpNumberOfBytesWritten:
[out] Покажчик на змінну, яка приймає кількість реально записаних байт.

lpOverlapped:
[in] Покажчик на структуру OVERLAPPED. При не асинхронному доступі слід передавати NULL.

Значення, що повертається:
Якщо виконання функції сталося успішно, то повертається ненульове значення.

## Блокування файлу


Блокування файлів:
Оскільки система дозволяє більш ніж одному з додатком відкривати файл і писати в нього, додатки не повинні одночасно писати в одну область файлу. Ця проблема може бути вирішена шляхом тимчасового блокування частини файлу. Функція LockFile дозволяє додатку отримати в монопольне користування певну кількість байт в файлі. Відрізок заблокованих байт може виходити за поточний кінець файлу. Всі спроби сторонніх додатків звернутися до заблокованої ділянки файлу зазнають невдачі.
Додаток може файл за допомогою функції UnlockFile.

```cpp
BOOL LockFile(
  HANDLE hFile, // дескриптор файлу
  DWORD dwFileOffsetLow, // молодше слово зміщення початку відрізка
  DWORD dwFileOffsetHigh, // старшее слово смещения начала отрезка
  DWORD nNumberOfBytesToLockLow, // молодше слово довжини відрізка
  DWORD nNumberOfBytesToLockHigh // старше слово довжини відрізка
);
```


Параметри:

hFile:
[in] Дескриптор файлу, в який проводиться запис. Повинен бути відкритий з доступом GENERIC_READ або GENERIC_WRITE (або обома).

dwFileOffsetLow:
[in] Визначає молодше слово зміщення початку блокується відрізка щодо початку файлу.

dwFileOffsetHigh:
[in] Визначає старше слово зміщення початку блокується відрізка щодо початку файлу. Не дорівнює нулю, якщо зсув щодо початку більш ніж 232 байт.

nNumberOfBytesToLockLow:
[in] Визначає молодше слово довжини блокується відрізка.

nNumberOfBytesToLockHigh:
[in] Визначає старше слово довжини блокується відрізка. Не дорівнює нулю, якщо довжина відрізка більше 232 байт або 4 ГБ.

Значення, що повертається:
Якщо виконання функції сталося успішно, то повертається ненульове значення.
Блокування надає процесу монопольний доступ до відрізка файлу. Файлові блокування не успадковуються. Решта процеси не можуть ні читати, ні писати в заблоковану частину файлу.

## Розблокування файлів


Функція UnlockFile дозволяє розблокувати ділянку файлу, раніше заблокований функцією LockFile.


```cpp
BOOL UnlockFile(
  HANDLE hFile, // дескриптор файлу
  DWORD dwFileOffsetLow, // молодше слово зміщення початку відрізка
  DWORD dwFileOffsetHigh, // старше слово зміщення початку відрізка
  DWORD nNumberOfBytesToUnlockLow, // молодше слово довжини відрізка
  DWORD nNumberOfBytesToUnlockHigh // старше слово довжини відрізка
);
```


Параметри цієї функції аналогічні параметрам функції LockFile.

Значення, що повертається:
Якщо виконання функції сталося успішно, то повертається ненульове значення.
Відрізок файлу, який розблокується функцією UnlockFile повинен в точності відповідати відрізку, заблокованого функцією LockFile. Наприклад, дві сусідніх частини файлу не можуть бути заблоковані окремо, а розблоковані як єдине ціле. Процес не повинен завершувати виконання, маючи заблоковані частини файлів. Файловий дескриптор, для якого є заблоковані відрізки, не повинен закриватися.

## Закриття файлів


Для оптимального використання ресурсів операційної системи програма має закривати непотрібні файли за допомогою функції CloseHandle. Файли, відкриті на момент завершення програми, закриваються автоматично.


```cpp
BOOL CloseHandle(
  HANDLE hObject // Дескриптор объекта (файла, канала и пр.)
);
```


Значення, що повертається:
Якщо виконання функції сталося успішно, то повертається ненульове значення.
