# ТИПИ ДАНИХ ТА ОПЕРАЦІЇ


## Зміст
* [Склад мови C++](lec-01.md)
* [02](lec-02.html)


## Типи даних

Обробка даних різного типу є головною метою будь-якої програми. Кожне з даних характеризується класом пам'яті, ім'ям, типом і значенням. Імена дозволяють ідентифікувати дані, тобто відрізняти їх між собою. Програміст обирає тип кожної величини, що використовується для подання реальних об'єктів. Тип задає множину можливих значень даних і способи їх зберігання, перетворення та використання.

Обов'язкове оголошення типу даних дозволяє компілятору робити перевірку допустимості різних конструкцій програми.

Усі типи даних мови C++ можна розділити на основні (базові) і складені. Основні типи визначені для представлення цілих, дійсних, символьних і логічних даних. На основі цих типів вводиться опис складених типів, до яких належать масиви, перелічення, функції, структури, посилання, покажчики, об'єднання і класи.

Основні типи даних (див. табл. 3.1) часто називають арифметичними, тому що їх можна використовувати в арифметичних операціях. Для опису основних типів мови C++ використовують такі службові слова:


* int (цілий);
* char (символьний);
* bool (логічний);
* float (дійсний);
* double (дійсний з подвійною точністю);
* void (порожній, не має значення).

Типи int, char, bool називають цілими, а типи float та double — дійсними з плаваючою крапкою. Код, що формує компілятор для обробки цілих величин, відрізняється від коду для величин з плаваючою крапкою.

Для уточнення внутрішнього подання та діапазону значень стандартних типів мова C++ використовує чотири специфікатори типу:


* short (короткий);
* long (довгий);
* signed (знаковий);
* unsigned (беззнаковий).

Таблиця З.1

Базові типи даних для ПК (платформа Intel)




|     |     |     |
| --- | --- | --- |
| Тип | Розмір, байт | Значення |
| **bool** | 1   | true або false |
| **unsigned short int** | 2   | від 0 до 65 535 |
| **short int** | 2   | від -32 768 до 32 767 |
| **unsigned long int** | 4   | від 0 до 4 294 967 295 |
| **long int** | 4   | від -2 147 483 648 до 2 147 483 647 |
| **int** (16 розрядів) | 2   | від -32 768 до 32 767 |
| **int** (32 розряди) | 4   | від -2 147 483 648 до 2 147 483 647 |
| **unsigned int** (16 розрядів) | 2   | від 0 до 65 535 |
| **unsigned int** (32 розряди) | 4   | від 0 до 4 294 967 295 |
| **char** | 1   | від 0 до 256 |
| **float** | 4   | від 1.2е-38 до 3.4е38 |
| **double** | 8   | від 2.2е-308 до 1.8е308 |
| **long double** | 10  | від 3.4е-4932 до 3.4е+4932 |

У табл. 3.1 наведено діапазони значень та розміри основних типів даних (для 16-розрядного і 32-розрядного процесорів). Розмір однакового типу даних може відрізнятися на комп'ютерах різних платформ, а також може залежати від застосованої операційної системи. Тому при оголошенні тієї чи іншої змінної потрібно чітко уявляти, скільки байт вона буде займати в пам'яті ЕОМ, щоб запобігти проблемам, пов'язаним з переповненням і неправильною інтерпретацією даних. Діапазони кожного з типів (див. табл. 3.1) повинні бути перевірені для конкретного комп'ютера.




## Змінні

Кожна програма потребує виконання різноманітних обчислень, для здійснення яких використовуються вирази, що складаються з операндів, знаків операцій і дужок. Операнди задають дані для обчислень, а операції задають дії, які необхiдно виконати над цими даними. Операнд є, у свою чергу, виразом, що в окремому випадку може бути константою або змінною.

Змінна — це іменована область пам'яті, у якій зберігаються дані визначеного типу. Змінна має ім'я, розмір та інші атрибути, такі як видимість, час існування тощо. Ім'я змінної служить для звертання до області пам'яті, у якій зберігається її значення. Перед використанням будь-яка змінна повинна бути описана, при цьому для неї резервується деяка область пам'яті, розмір якої залежить від конкретного типу змінної. Під час виконання програми змінна може приймати рiзнi значення.

Наведемо загальний вигляд опису змінних:

[клас пам'яті] [const] тип ім'я [ініціювання];
&nbsp;

де необов'язковий клас пам'яті може приймати одне зі значень — auto, extern, static чи register (у посібнику при описі синтаксису об'єктів програмування необов'язкові частини синтаксичних конструкцій мови подано у квадратних дужках «[]»);

модифікатор const вказує, що змінна не може змінювати своє значення, у цьому випадку її називають типізованою (іменованою) константою або просто константою;

ініціювання — це присвоювання змінній при описі початкового значення, яке записується зі знаком рівності — = значення або в круглих дужках — (значення). Зазначимо, що константа повинна бути ініційована при описі. Один оператор може містити опис декількох змінних одного типу, розділяючи їх комами, наприклад:


const int n = 20, m = 5, k = 4; // — ініціювання констант n, m, k цілого типу;
float h = 17.5, d(5.5), sum; // — опис дійсних змінних h, d, sum, ініціювання h і d;
char sf = 'f', st[ ] = "Мудрость лишь в истине."; // — ініціювання символьних змінних.

Якщо тип значення, що ініціюється, не збігається з типом змінної, то виконуються перетворення типу. Кожна змінна повинна мати своє ім'я, причому в одному блоці не може бути двох змінних з однаковим ім'ям.

Областю дії ідентифікатора змінної є частина програми, в якій його можна використовувати для доступу до зв'язаної з ним області пам'яті. Залежно від області дії змінна може бути локальною або глобальною.

Локальна змінна визначена всередині блока (нагадаємо, що блок розташований між фігурними дужками). Область її дії обмежена початком опису змінної та кінцем блока, включаючи усі вкладені блоки. Змінна, визначена поза будь-яким блоком, називається глобальною, і областю її дії вважається файл, у якому вона визначена від початку опису до його кінця.

Клас пам'яті визначає час існування та область видимості програмного об'єкта, тобто змінної. Якщо клас пам'яті не зазначений явно, то він визначається компілятором, виходячи, з контексту оголошення.

Час існування змінної може бути постійним (протягом виконання програми) і тимчасовим (протягом виконання блока).

Областю видимості ідентифікатора називається частина тексту програми, з якої можна здійснити звичайний доступ до зв'язаної з ідентифікатором області пам'яті. Найчастіше область видимості збігається з областю дії. Винятком є ситуація, коли у вкладеному блоці описана змінна з таким же ім'ям. У цьому випадку зовнішня змінна у вкладеному блоці невидима, хоча він і входить до її області дії. Проте до цієї змінної, якщо вона глобальна, можна звернутися, застосовуючи операцію доступу до області видимості — ::.

Клас пам'яті задають такі специфікатори:


* auto — автоматична змінна, для якої пам'ять виділяється у стеку і за необхідності ініціюється кожного разу при виконанні оператора, що містить її визначення. Звільнення пам'яті відбувається при виході з блока, де описана змінна. Час її існування — з моменту опису до кінця виконання блока. Для глобальних змінних цей специфікатор не використовується, а для локальних він приймається за замовчуванням, тому задавати його явно великого сенсу немає;
* extern означає, що змінна визначена в іншому місці програми (в іншому файлі або далі по тексту) і використовується для створення змінних, доступних в усіх модулях програми, де вони оголошені. При ініціюванні змінної у тому ж операторі, спеціфікатор extern ігнорується;
* static — статична змінна, що має постійний час існування. Вона ініціюється один раз при першому виконанні oпeратора, що містить визначення змінної. Залежно від розташування оператора, описані статичні змінні можуть бути глобальними і локальними. Глобальні статичні змінні видимі тільки у тому модулі, в якому вони описані;
* register — аналогічний до специфікатора auto, але пам'ять видiляється по можливості в регістрах процесора і за відсутності такої можливості у компілятора змінні обробляються як auto.

Наведемо фрагмент програми з використанням розглянутих вище понять:

```cpp
int d;               //1 — глобальная переменная d
int main()
{
int b;              //2 — локальная переменная b
extern int y;     //3 — переменная у определена в другом месте программы 
static int s;      //4 — локальная статическая переменная s
d = 1;           //5 — присваивание значения глобальной переменной 
int d;            //6 — локальная переменная d
d = 10;         //7 — присваивание значения локальной переменной
::d = 3;        //8 — присваивание значения глобальной переменной 
return 0;
}
int у = 4;       // 9 — определение и инициализация переменной у
```


У цьому прикладі глобальна змінна d визначена поза всіма блоками. Пам'ять для неї виділяється в сегменті даних на початку роботи програми, областю дії є вся програма. Область видимості — вся програма, крім рядків 6-8, тому що в першому з них визначається локальна змінна з тим же ім'ям, область дії якої починається з початку її опису і закінчується при виході з блока. Змінні b i s — локальні, область їх видимості — блок, але час існування різний: пам'ять під b виділяється в стеку при вході у блок і звільняється при виході з нього, а змінна s розташована у сегменті даних та існує увесь час роботи програми. Якщо початкове значення змінних явно не задається, компілятор присвоює глобальним і статичним змінним нульове значення відповідного типу. Автоматичні змінні не ініціюються. Початкове ініціювання змінних не є обов'язковим, проте все ж його бажано здійснювати.

Опис змінної може виконуватися у формі оголошення або визначення. Оголошення інформує компілятор про тип змінної і класи пам'яті, а визначення містить, крім цього, вказівку компілятору про виділення пам'яті відповідно до типу змінної. У C++ більшість оголошень є одночасно і визначеннями (у наведеному вище програмному фрагменті тільки опис extern int у; є оголошенням, але не визначенням). Змінна може бути оголошена багаторазово, а визначена тільки в одному місці програми, оскільки оголошення тільки описує властивості змінної, а визначення зв'язує її з конкретною областю пам'яті.

Розглянемо далі основні типи змінних.

Цілі змінні (типу int, long, short) необхідні для збереження цілих значень і можуть бути знаковими і беззнаковими. Знакові змінні застосовують для подання як додатних, так і від'ємних чисел, при цьому один біт (найстарший) виділяється під знак. Для оголошення беззнакової змінної, тобто змінної, що приймає тільки додатні значення, необхідно використовувати ключове слово unsigned. За замовчуванням будь-який цілий тип вважається знаковим, і тому немає потреби у використанні ключового слова signed.

Символьний тип даних char застосовується у випадку, коли змінна містить інформацію про код ASCII або для побудови таких більш складних конструкцій, як рядки, символьні масиви тощо. Дані типу char також можуть бути знаковими і беззнаковими.

Змінна типу bool займає 1 байт і використовується, насамперед, у логічних операціях, тому що може приймати значення 0 (false — «неправда») або відмінне від нуля (true — «істина»). У випадку перетворення до цілого типу true має значення 1.

Стандарт C++ визначає три типи даних для збереження дійсних значень змінних: float, double та long double (типи з плаваючою крапкою). Тип float, як правило, використовують для збереження не дуже великих дробових чисел.

Змінна типу void не має значення, оскільки множина значень цього типу порожня. Такі змінні необхідні для узгодження синтаксису. Тип void використовується для визначення функцій, що не повертають значення, для вказівки порожнього списку аргументів функції, а також як базовий тип для покажчиків i в операції приведення типів. Наприклад, якщо немає потреби у використанні поверненого значення функції, перед ім'ям функції ставиться тип void:

```cpp
void minmax(int *x, int k, int *min, int *max);
```



## Константи

Константи являють собою фіксовані значення, що не можуть змінюватися впродовж виконання всієї програми.

Спосіб визначення кожної константи залежить від її типу. Константи мови С++ слід поділяти на літеральні та типізовані.

Літеральна константа— це лексема, що являє собою зображення фіксованого числового, рядкового або символьного значення. Такі константи бувають цілі, дійсні, символьні та рядкові(табл. 3.2).




Таблиця 3.2


Літеральні константи мови


|     |     |     |
| --- | --- | --- |
| Таблиця 3.2 | Літеральні константи мови |     |
| Константа | Формат | Приклади |
| Цiла | Десятковий: послідовність десяткових цифр  (0, 1, 2, 3, 4, 5, 6, 7, 8, 9),  що починається не з нуля, якщо це не число нуль | 9, 0, 217925 |
|     | Вісімковий: нуль, за яким розташова­ні вісімкові цифри  (0, 1, 2, 3, 4, 5, 6, 7) | 02, 050, 07245 |
|     | Шістнадцятковий: 0х чи 0Х, за яким розташовані шістнадцяткові цифри  (0, 2, 3, 4, 5, 6, 7, 8, 9, А, В, С, D, Е, F) | 0x1B9, 0X00FF |
| Дійсна | Десятковий:\[цифри\].\[цифри\]Експоненціальний:  \[цифри\]\[.\]\[цифри\]{Е\|е}\[+\|-\]\[цифри\] | 9.7, .001, 87. 0.7Е6, .15е-3 9.2, 920 е-2, 92.Е-1, .92Е1 |
| Символьна | Один чи два символи, що подаються в апострофах | 'А' , 'ю' , '\* ' , 'db' ,  '\\0', '\\n', '\\012',  '\\х07\\х07' |
| Рядкова | Послідовність символів, що подають­ся в лапках | RESULT”,  \\t sum__s=\\0x5\\n” |


Цілі константи можуть бути десятковими, вісімковими та шiстнадцятковими.

Довгі цілі константи (long) мають літеру l або L в кінці, наприклад: 32768L; 0777777l; 0XFL. Для завдання константи, без знака (unsigned) застосовується літера u (U),наприклад 65535u. Довгі константи без знака записуються з використанням двох літер відразу: (ul, UL) або (lu, LU).

Дійсні числа у мовах програмування мають дві форми подання: десяткову (природну) та експоненціальну (показникову).

Десяткова форма дійсного числа — це звичайний десятковий формат запису дійсного числа, тільки частина дійсного числа відділяється від дробової крапкою, а не комою, наприклад 10.123, 1.0123, 1012.3, 0.0010123.

Експоненціальна форма дійсного числа використовується для запису дуже великих або дуже малих чисел, для яких задавати зайві нулі не зовсім зручно, наприклад: 1 .0123*1020,1.0123*10-10. У цій формі запису числа можна виділити такi основні характеристики: знак числа, мантису числа, знак порядку та порядок числа. Зазначені характеристики дійсного числа зберігаються у пам'яті комп'ютера. Число у показниковій формі може бути представлено, наприклад, так: 1.0123Е-10. Мантиса записується ліворуч від знака експоненти(Е чи е), порядок — праворуч. Символ Е (е) означає основу степеня 10, і компілятор розпізнає цей запис як форму представлення дійсного числа. Символ пропуску всередині числа не допускається, а для відділення цілої частини від дробової використовується не кома, а крапка. При додатних значеннях числа і мантиси знак «+» можна не вказувати.

Як десяткова, так і екcпоненціальна форми запису допускають відсутність або цілої частини, або дробової, але не двох одразу.

За замовчуванням всі дійсні константи мають тип double— подвійну точність, що найчастіше займає в пам'яті 64 біти, тобтo 8 байтів. Але у випадку, якщо програміста не влаштовує тип за замовчуванням, його можна вказати явно за допомогою спеціальних літер. Так, додавши літеру f чи F, константі надають дійсний тип float зі звичайною точністю, наприклад, 8.5f. Якщо в представленні константи використовується літера L чи l, то вона має тип long double.

Зображення від'ємної цілої чи дійсної константи вважається константним виразом, що складається зі знака унарної операціi зміни знака (-) та константи, наприклад: -273, -2730.е-1, -273L.

Символьні константи мають один або два символи, що подаються в апострофах. Односимвольні константи займають у пам'яті один байт і мають стандартний тип char (character-символ). Двосимвольні константи займають два байти і мають тип int. Символьні константи мають цілий тип і їх можна використовувати як цілочислові операнди у виразах.

Заслуговують уваги послідовності, що починаються зі знака «\», їх називають керуючими або escape-послідовностями. Символ зворотної косої риски «\» використовується для запису кодів,що не мають графічного зображення, для запису символiв, а також для виведення символьних констант, якщо їх коди заданi у вісімковому та шістнадцятковому вигляді (табл. 3.3).

Таблиця 3.3

Керуючі послідовності мови С++





\а


звуковий сигнал



\b


повернення на крок



\f


переведення сторінки (формату)



\n


новий рядок



\r


повернення каретки



\t


горизонтальна табуляція



\v


вертикальна табуляція



\\


символ \ — зворотна коса риска



\&#8217;


символ &#8216; — апостроф



\&#8221;


символ &#8221; — лапки



\0


нуль-символ



\?


знак питання



\0ddd


вісімковий код символу



\0xddd


шістнадцятковий код символу



Рядкова константа(рядковий літерал)— це послідовність cимволів,що подається в лапках (тобто в символах «&#8221;» )і зберігаеться у неперервній ділянці пам'яті, наприклад: Это строковый литерал&#8221;. У кінець кожного рядкового літералу компілятором додається нуль-символ,що предствляється керуючою послідовністю «\0».Тому довжина рядка завжди на одиницю більше кількості символів у його записі. Таким чином, порожній рядок (&#8221; ) має довжину 1 байт. Слід звернути увагу на різницю між рядком з одного символу, наприклад, С&#8221; і символьною константою &#8216;С&#8217; . Порожня символьна константа неприпустима.

Керуючі послідовності можуть також застосовуватись у рядкових константах. Так, якщо всередині рядка потрібно записати лапки, то перед ними слід розташувати зворотну косу риску («\»), за якою компілятор відрізняє їх від лапок, що обмежують рядок:

Книга имеет название \&#8221;Язык прогаммирования С++\” .

Рядки,що записані у програмі підряд або через символи пропуску, при компіляції конкатенуються («склеюються»). Тобто послідовність двох рядків

Уча других, мы учимся сами.&#8221;
Успех —это успеть.&#8221;
цілком еквівалентна рядку:

Уча других, мы учимся сами. Успех — это успеть.&#8221;.

Довгу рядкову константу можна розмістити також на декількох рядках. У цьому випадку ставиться зворотна коса риска і натискається клавіша Enter. Наприклад:

Компьютерная программа выполняет то, \
что вы ей приказали делать, а не то, \
что вы хотели, чтобы она делала.”
Поняття та приклади оголошення типізованої константи, тобто константи, що використовується як змінна, значення якoї не може бути змінене після ініціювання, розглянуті вище.

Існує інша можливість задання констант — з використанням директиви препроцесора #define,при цьому оголошення має вигляд:

#define ім'я константи значення константи
і наприкінці такого запису символ «;» не ставиться, тобто:

#define max 65532
#define km 1000.
Директива #define визначає ідентифікатор (ім'я константи) і послідовність символів (значення константи), яка замінює ідентифікатор у тексті програми.

Нульовий покажчик (NULL-покажчик)— єдина неарифметична константа мови C++.

При застосуванні великої кількості логічно взаємозалежних констант C++ доцільно користуватися константами перелічення. Тип перелічення має вигляди:


enum {список іменованих констант}; // —н еiменоване перелічення,
enum [ім'я] {список іменованих констант}; // — iменоване перелічення.


де


enum—службове слово(enumerate—перелічувати);
ім&#8217;я— ім'я списку констант;
список іменованих констант— розділена комами послідовнiсть iдентифікаторів або іменованих констант вигляду:

ім'я константи = значення константи.

Наприклад:


enum {Anton, Ivan, Piter};
enum Months {January = 1, February, Marth, April, May, June, July, August, September, October, November, December};


Якщо значення константи перелічення не визначено, то воно на одиницю більше значення попередньої константи. За замовчуванням перша константа має значення 0. Тоді у першому прикладі константи одержать значення:Anton = 0, Ivan = 1, Piter = 2, а у другому — значення: January = 1, February = 2, Marth= З тощо. Іменовані перелічення задають унікальний цілочисловий тип і можуть використовуватися як специфікації типу для визначення змінних.



## Операції

Для здійснення маніпуляцій з даними мова C++ застосовує широкий набір операцій (див. табл. 3.4), що виконують формування і, відповідно, подальше обчислення виразів. Вирази містять одну або декілька операцій, об'єкти яких називають операндами. Операції являють собою деяку дію, що виконується над одним (унарна) або декількома (бінарна, триарна) операндами , і мають позначення (наприклад, операція перевірки на рівність — позначення «==», операція обчислення залишку від ділення цілих чисел — позначення «%» тощо).

Операції поділяються на:


* унарні або одномісні — &amp;, *, -, +, ~, !, ++, &#8211;-, sizeof;
* бінарні або двомісні — +, -, *, /, %, &lt;&lt;,  &gt;&gt;, &amp;, :, ^, &lt;, &gt;, &lt;=, ==, &gt;=, !=, &amp;&amp;, ||, =,*=, /=, %=, +=, -=, &lt;&lt;=, &gt;&gt;=, &amp;=, |=, ^=, ., -&gt;, ,, (), [];
* умовну триарну або тримісну операцію — ?: .

Таблиця 3.4

Основні операції мови C++




 №
 Операції
 Порядок виконання


1
 ()  ,  {}  -&gt;  .
Л -&gt; П


2
  !   ~   ++    *   (type)
 П  - Л


3
 sizeof
 П  - Л


4
 *   /   %
Л - П


5
 +  
 Л - П


6
 &lt;&lt;   &gt;&gt;
 Л -&gt; П


7
 &lt;   &lt;=   &gt;   &gt;=
 Л -&gt; П


8
 ==   !=
 Л -&gt; П


9
 &amp;
 Л -&gt; П


10
 ^
 Л -&gt; П


11
 |
 Л -&gt; П


12
 &amp;&amp;
 Л -&gt; П


13
 ||
 Л -&gt; П


14
 ?:
П -&gt; Л


15
 =   +=   *=   -=   /=   %=
 П -&gt; Л


16
 ,
Л -&gt; П



Порядок застосування операції визначається пріоритетом операції (яка операція виконується раніше, а яка пізніше) та асоціативністю (виконується зліва направо або справа на ліво). У першу чергу реалізуються операції з найвищим пріоритетом.

У табл. 3.4 літерою «Л» позначено величину, що стоїть ліворуч від знака операції, літерою «П» — величину, яка розташована праворуч від знака операції, а символом «-&gt;» напрямок виконання операції. Розглянемо основні операції.

Арифметичні операції:

     + — додає величину П до Л;
     &#8211;     — віднімає П із Л;
     &#8211;     — унарна операція зміни знака величини П;
     *     — множення П і Л;
     / — ділення Л на П;
    % — залишок від ділення величини Л на величину П (для цілих чисел), наприклад, якщо int g = 12;, то операція g = g % 9; надасть результат: g = 3;
++ — унарна операція інкремент. Якщо змінна розташовується праворуч від знака операції (префіксна форма), то значення збільшується на 1 до використання. Якщо ж змінна знаходиться ліворуч від знака операції (постфіксна форма), то її значення збільшується на 1 після використання, наприклад:


int d;
++d; — префіксний інкремент,
d++; — постфіксний інкремент;

&#8212; — унарна операція декремент аналогічно інкременту має двi форми: префіксную (змінна розташована праворуч від знака операцii) — зменшення значення змінної на 1 відбувається до її використання; постфіксну (змінна знаходиться ліворуч від знака операції) — зменшення значення змінної на 1 після її використання.

Операції присвоювання:
= — присвоювання значення П змінній Л;
+= — додає величину П до змінної Л;
&#8211;= — віднімає величину П від змінної Л;
*= — множення змінної Л на величину П;
/= — ділення Л на П;
%= — видає залишок від ділення Л на П.

Просте присвоювання здійснює операція «=». Допускається одночасне зчіплювання декількох операцій присвоювання за умови, що всі операнди мають однаковий тип, наприклад:


int і, j, с;
i = j = с = 0; .

Операції «+=», «-=», «*=», «/=» виконують складні присвоювання і дозволяють записувати вирази коротше, наприклад:


s += 7;        //s=s + 7;
  і *= j + 5;   //i=i*(j +5);
g%=9;        //g=g%9;.

Операції відношення порівнюють значення Л зі значенням П:
&lt; — менше;
&lt;= — менше або дорівнює (не перевищує);
== — дорівнює;
&gt; — більше;
&gt;= — більше або дорівнює (не менше);
!= — не дорівнює.

У мові C++ «істина» — це ненульова величина, «неправда» — це нуль (0). У більшості випадків одиниця (1) викориcтовується як ненульове значення.

Операції відношення повертають ціле значення 1, якщо умова вірна, або 0, якщо умова помилкова.

Логічні операції оперують з цілими розмірами або з розмірами, які можна перетворити на цілі. Обчислення зупиняється, які тільки визначиться, чи є вираз правдивим («істина») або помилковим («неправда»). При цьому, як і для операцій відношення, значенням «істина» відповідає 1, а значенням «неправда» — 0.

&amp;&amp; — логічне «AND» (кон'юнкція);
||    — логічне «OR» (диз'юнкція);
!= — логічне «NOT» (заперечення).

Результат операції «&amp;&amp;» є «істина» (1), якщо обидва її oпeранди правдиві (не рівні 0). Результат операції «||» — «істина» (1), якщо хоча б один з її операндів є «істина». Логічне заперечення «!=» перетворює свій операнд на «істину» (1), якщо він дорівнює 0, і на «неправду» (0), якщо він не дорівнює 0.

З  використанням логічних операцій та операцій відношення записуються різні умовні вирази, наприклад, умова 3 &lt; х &lt; 5 матиме вигляд: х &gt; 3 &amp;&amp; х &lt; 5.

Операції обробки окремих бітів застосовують для обробки даних як послідовностей бітів (розрядів), кожний з яких набуває значення 0 або 1.

&amp;    — операція бітового множення (кон'юнкція);
|    — операція бітового додавання (диз'юнкція);
^    — додавання за модулем 2;
~    — інвертування;
&gt;&gt; — зсув праворуч;
&lt;&lt; — зсув ліворуч.

Змінна-покажчик зберігає значення, що є адресою об'єкта в пам'яті комп'ютера. Через покажчик можна звертатися до об'єкта.

Операції з адресами та покажчиками:

&amp; — одержання адреси: видає адресу змінної, ім'я якої розташоване праворуч від позначення операції;
* — непряма адресація (розіменування): видає значення, записане за адресою, на яку посилається покажчик.
Додаткові операції:
  sizeof() — знаходить розмір (у байтах) операнда, розташованого праворуч від назви операції;
  (type) — операція приведення типу перетворює наступне за нею значення в тип, визначений ключовим словом, укладеним у круглі дужки, наприклад:
i = i+(int)*3.14;
?: —  триарна (з трьома операндами)     операція, що має вигляд:

вираз1? вираз2 : виразЗ;,
тут, якщо результат обчислення першого операнда (вираз1) не дорівнює 0 («істина»), то результатом операції буде значення другого операнда (вираз2), інакше — третього операнда (виразЗ). Наприклад, знаходження найбільшої з двох величин а і b, можливо здійснити операцією: max = (b &gt; а)? b : а;.

Мова C++ налічує широкий спектр математичних функцій (табл. 3.5). Для їх використання слід включити в код програми заголовний файл math.h.

Таблиця 3.5

Математичні функції (заголовний файл math.h)

&nbsp;





Прототип функції


Ім'я

Призначення




Double sin (double _х);
sin (x)
синус x (в радіанах) — sin x


Double cos (double _x);
cos (x)
косинус x (в радіанах) — cos х


Double tan (double _x);
tan (x)
тангенс х (в радіанах) — tg х


Double asin (double _x);
asin (x)
арксинус х — arcsin х


Double acos (double _x);
acos (x)
арккосинус х — arcos х


Double atan (double _x);
atan (x)
арктангенс х — arctg х


Double atan2 (double _y, Double_x);
atan2 (y,x)
арктангенс у/х — arctg (у/х)


Double sinh (double _x);
sinh (x)
синус гіперболічний х — sh х


Double cosh (double _x);
cosh (x)
косинус гіперболічний х — ch х


Double tanh (double _x);
tanh (x)
тангенс гіперболічний х — th х


Double log (double _x);
log (x)
натуральний логарифм х — ln х


Double log10 (double _x);
log10 (x)
десятковий логарифм х — log х


Double exp (double _x);
exp (x)
піднесення е до степеня х — ех


Double pow (double _x, double_y);
pow (x,y)
піднесення х до степеня у — ху


Double pow 10 (int _p)
pow10 (p)
повертає 10р


Double sqrt (double _х);
sqrt (x)
корінь iз x, x &gt; 0


Double hypot (double_x, double_y);
hypot (x,y)
корінь із (х2+у2)


Double fabs (double __x);
fabs (x)
абсолютне значення х — |х| типу double


int abs (int _x);
abs (x)
абсолютне значення х — |х| типу int


long labs (long _x);
labs (x)
абсолютне значення х — |х| типу long


Double fmod (double __x, double_y);
fmod (x,y)
залишок від ділення х на у


Double ceil (double __x);
ceil (x)
округлення до більшого


Double floor (double _x);
floor (x)
повертає найближче ціле, не більше за х


Double modf (double _x, double);
modf(x,&amp;p)
виділяє цілу й дробову частинні числа


Double atof(const char* _s);
atof (s)
перетворює рядок символів
у число з плаваючою крапкою



Визначені константи: М_РІ = 3.1415&#8230; — пи, М_Е = 2.71828&#8230; — е, M_SQRT2 = 1.4142&#8230; — sqrt(2), M_LN2 = 0.6931&#8230; — ln(2) тощо.



## Контрольні запитання


1. Які основні та складені типи даних має мова С++?

1. Що таке змінна і як здійснюється її опис та визначення?

1. Що таке «область дії ідентифікатора» та «клас пам'яті»?

1. Які константи налічує С++? Охарактеризуйте їх застосування

1. Що таке пріоритет операції? Наведіть приклади арифметичниx та логічних операцій

1. Які операції присвоювання та операції відношення налічує С++?

1. Що реалізують логічні операції та операції обробки окремих бітів?

1. Які операції над покажчиками та додаткові операції має С++?





