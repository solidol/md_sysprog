# Покажчики у С++

## Перелік лекцій

1.  [Склад мови С++](lec-01.md)
2.  [Дані та операції](lec-02.md)
3.  [Організація введення-виведення даних](lec-03.md)
4.  [Основні оператори С++](lec-04.md)
5.  [Масиви у С++](lec-05.md)
6.  [Покажчики у С++](lec-06.md)
7.  [Дані символьного типу](lec-07.md)
8.  [Дані типу структура](lec-08.md)
9.  [Функції](lec-09.md)
10. [Робота з файлами](lec-10.md)
11. [Системні бібліотеки WinAPI32](lec-11.md)
12. [Обробка файлів за допомогою WinAPI32](lec-12.md)
13. [Об'єктно-орієнтоване програмування. Класи](lec-13.md)
14. [Методи та властивості. Екземпляри класу](lec-14.md)
15. [Паралельні обчислення за стандартом OpenMP](lec-15.md)
16. [Паралельні обчислення з бібліотекою MPI](lec-16.md)

## Покажчики та масиви


Покажчики — це змінні, котрі містять адресу пам’яті, розподіленої для об’єкта відповідного типу. Усі змінні, розглянуті до цього, зберігали якісь значення (дані). Ці дані могли бути різних типів: символьного, цілого, дійсного тощо. При оголошенні змінної-покажчика слід вказати тип даних, адресу яких буде містити змінна, та ім’я покажчика з символом «\*».



Загальний формат опису покажчика має вигляд:


`<тип> *<ім’я>;`



де тип — тип значень, на який вказує покажчик;
ім’я — ім’я змінної-покажчика;
«\*» — операція над типом, що читається «покажчик на тип».



Наприклад:


```cpp
int *рn; // покажчик на ціле значення;
float *pf1, *pf2; // два покажчики на дійсні значення.
```




Покажчики не прив’язують дані до якого-небудь визначеного імені змінної і можуть містити адреси будь-якого неіменованого значення. Існує адресна константа NULL, що означає порожню адресу.



Слід нагадати, що мова C++ налічує лише дві операції, які стосуються адрес змінних, а саме:



«&» — операція взяття адреси («адреса значення»);



«\*» — операція розіменування («значення за адресою»).



Операція взяття адреси «&» застосовується разом зі змінною і повертає адресу цієї змінної. Операція розіменування «\*» використовується разом з покажчиками і вилучає значення, на яке вказує змінна-покажчик, розташована безпосередньо після символа «\*».



Оголошення покажчиків можна здійснити одним з таких способів:


`
<тип> *ptr;
<тип> *ptr = <змінна-покажчик>;
<тип> *ptr = &<ім’я змінної>;
`


Наприклад:
`int *ptx, b; float у;` — оголошені змінна-покажчик ptx та змінні b і у;



`float *sp = &у;` — покажчику sp присвоюється адреса змінної у;



`float *р = sp;` — покажчику р присвоюється значення (адреса значення), яке міститься в змінній sp, тобто адреса змінної у.



При оголошенні покажчиків символ «\*» може знаходитися перед ім’ям покажчика або відразу після оголошення типу покажчика і поширювати свою дію тільки на одну змінну-покажчик, перед якою він записаний:



`long *pt; long *Uk; int *ki, x, h;` — оголошення описів.



За потреби для опису покажчика на комірку довільного типу замість ідентифікатора типу записується слово void, а саме:



`void *р, *pt;` — опис двох покажчиків на довільний тип даних.



Перед використанням покажчика у програмі його обов'язково необхідно ініціювати, іншими словами, необхідно присвоїти адресу якого-небудь даного, інакше можуть бути непередбачені результати.



Для одержання доступу до значення змінної, адреса якої зберігається в покажчику, досить у відповідному операторі програми записати ім’я покажчика з символом «\*» — здійснити операцію розіменування.



Розглянемо фрагмент програми з поясненнями:



`int *р, *р1;` — оголошені два покажчики на комірку пам’яті типу int;



`int х = 12, у = 5, m[7];` — оголошені змінні х, у і масив m, змінні ініційовані;



`р = &у;      // р (&у);` — покажчику р присвоєна адреса змінної у.



Якщо для цього фрагмента програми записати оператор виведення у вигляді



`cout << "Адрес р " << р << "Значение по этому адресу = " << *р;`,



то виведеться адреса комірки пам’яті, де записана змінна у і значення цієї змінної (тобто 5).



Використовуючи запис `х = *р;`, одержимо `х = 5`, тому щo `*р = у = 5;`.



Змінити величину параметра у можна так:


```cpp
у = 10; // *Р= 10;
*р = *р+5; //у +=5;
```

Остання операція означає збільшення значення змінної у цiлого типу на 5, тобто у= 15.



При ініціюванні покажчиків їм можна присвоювати або адресу об’єкта (змінної), або адресу конкретного місця пам’яті (масиву), або число 0 (нуль), а саме:


```cpp
int *pt = (char *) 0x00147; // — присвоюється адреса комірки;
int *arrpt = new int [10]; // — визначається початкова адреса розміщення динамічного масиву;
char *р = 0; // — здійснюється ініціювання нулем.
```




Оскільки покажчики — це спеціальні змінні, то в операціях з іншими покажчиками вони можуть використовуватися без символа «\*», тобто без розкриття посилання, наприклад:


```cpp
float *pt1, *pt2, х=15, m[5];
pt1 = &x; 
pt2 = pt1;
pt1 = m;         //pt1 = &m[0];
```

де  m — ім’я масиву, що розглядається як спеціальний покажчик-константа.



Приклад 6.6. Написати ілюстраційну програму з використанням покажчиків.


```cpp
// P6_6.CPP — применение указателей 
#include <iostream.h>
#include <conio.h>
int main ( )
{ int x = 10;
  int *px (&x);   // int *px = &x;
cout << "x =" << x << endl; 
  cout << "*px =" << *px << endl;
  x *= 2;          //x=x*2;
  cout << "Новое значение *px = " << *px << endl;*
  px += 2;       // *px=*px + 2;
  cout << "Результат *px, т. e. x = " << x << endl;
  getch();     //задержка экрана
}
```




Результат виконання програми:

```cpp
х = 10 
*рх = 10
```
```
Новое значение *рх = 20 
Результат *рх, т. е. х = 22
```




Для змінної-покажчика існує своя адреса і тому будуть до цільними записи:



`int *pt1, *pt2;`



`pt1 = (int*) &pt2;` — покажчику pt1 присвоюється адреса пам'ятi де розташована змінна pt2.



Це має сенс у випадку, коли


```cpp
int у, *pt1, *pt2 = &у;
pt1 = (int*) &pt2;
```




Обмеження на застосування операції взяття адреси:



* не можна визначати адресу літеральної константи (оскільки для неї не виділяється комірка пам’яті), тобто такий запис, як vp = &345; — неприпустимий;
* не можна визначати адресу результату арифметичного виразу, тобто запис vp = &(x + y); теж неприпустимий.


Дозволені операції для змінних-покажчиків:



* операція розіменування «\*»;
* операція взяття адреси «&»;
* операція присвоювання «=»;
* операції інкремент «++» і декремент «--»;
* операції додавання «+» і віднімання «-»;
* операції відношення (порівняння) покажчиків однакового типу: «==», «!=», «<», «<=», «>», «>=».


У мові C++ масиви і покажчики зв’язані між собою: ім’я масиву визначається як покажчик-константа на початковий (нульовий)елемент масиву. Так, наприклад, при оголошенні одновимірного масиву у вигляді int mas [20]; його ім’я mas - покажчик на адресу початкового елемента масиву &mas[0].



Існує два способи доступу до елементів масиву:



* з використанням індексу елемента масиву, наприклад, mas[2] або mas[i];
* з використанням адресного виразу, тобто виразу з покажчиком на масив, наприклад, `*(mas + 2)` або `*(mas + і)`.


Ім’я покажчика на масив можна записати так:



int mas [20];
int *ptr1;
ptr1 = mas;      //ptr1 = &mas[0];,



тут вирази &mas[0] і mas — еквівалентні.



Оскільки в комп’ютері для масивів завжди є суцільний блок комірок пам’яті, в яких розташовуються їх елементи, то адресу наступного елемента mas[1] можна вказати шляхом збільшення покажчика на 1, а саме:



р = &mas[0];



р++;            //р=р  + 1;



Таким чином, адреса і-го елемента визначається як р + і. При цьому з урахуванням типу масиву і відведеної кількості байтів для кожного його елемента автоматично виконується операція збiльшення адреси, тобто:



адреса х[і] = адреса х[0] + i*sizeof (тип); .



Слід зауважити, що для покажчиків, які посилаються на елементи масивів різних типів, результат арифметичних операцій і операцій відношення невизначений.



До двох покажчиків р1 і р2, що вказують на елементи одного масиву, застосовують операції відношення: «==», «!=», «<», «<=», «>», «>=». При цьому значення покажчиків розглядаються як цілі числа, а результат порівняння дорівнює 0 ( »неправда») або 1 («істина»). Так, відношення вигляду р1<р2 є «істина», якщо р1 указує на більш ранній елемент, ніж р2. Будь-який покажчик можна порівняти з нулем.



В арифметиці з покажчиками можна використовувати адресу неіснуючого «наступного за масивом» елемента. До покажчиків можна додавати або віднімати від них цілу величину.



В обох випадках результатом операції буде покажчик на вихідний тип, значення якого на вказане число елементів більше або менше вихідного. Тобто, якщо до покажчика р можна додати деяку цілу величину n, а саме: р + n, то цей вираз визначає ділянку об’єкта, що займає n-не місце після об’єкта, на який вказує р, при цьому n автоматично збільшується на коефіцієнт, що дорівнює відповідній довжині об’єкта. Наприклад, якщо int займає 4 байти, то цей коефіцієнт дорівнює чотирьом.



Допускається також операція віднімання покажчиків, що вказують на елементи одного масиву. Так, якщо р1 < р2, то р2 - р1 + 1 — це число елементів масиву від р1 до р2 включно.



Наведемо приклади програм роботи з покажчиками.
Приклад 6.7. Обчислити середнє значення додатних елементів одновимірного масиву.



Розглянемо перший варіант програмної реалізації цієї задачі (див. Р6_7_1.СРР).



/* Р671.СРР — вычисление среднего значения положительных элементов массива */
//---------------- программа без использования указателей
#include <iostream.h>
#include <conio.h>
main( )
{ const int n = 10;
  float mas[n], s = 0;
  int i, kol = 0;
  cout << "Ввод массива " << endl;
  for(i =0; і < n; i++)
    cin >> mas[i]; 
      for(i = 0; і < n; i++)   
        if (mas[i] > 0)  
{ s += mas[i];           //накопление суммы
          kol++;  //подсчет положительных елементов
        }
 cout.precision(3 ) ; 
  cout << "Средн. арифм. полож. элементов = " << s/kol << endl; 
 getch();         //задержка экрана вывода резулътата
}



Результати виконання програми:


Ввод массива
1.56 -4.78 6.5 7.89 -3.6 9.45 7.4 -8.43 9.3 -10.2
Средн. арифм. полож. элементов = 7.02



Використовуючи ім’я масиву як покажчик на початок масиву (перший елемент), можна навести другий варіант програми (див. Р6_7_2.СРР):



// Р6_7_2.СРР - использование имени массива как указателя
#indude <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;  
  float mas[n], s;  
  int i, kol = 0;
  for (і = 0, s = 0; і < n; i++)
  { сіn >> *(mas+i);
    if (*(mas+i) > 0)
     { s += *(mas+i);
       kol++; }  
  } 
  cout.precision(3); 
  cout <<"\n Среднее арифм. полож. элементов = " << s/kol << endl; 
  getch();
}



Якщо описати покажчик і зв’язати його з масивом (адресувати на початок масиву), то з використанням арифметики покажчиків можна написати третій варіант (див. Р6__7_З.СРР) цiєї програми.



// Р6_7_3. СРР — использование арифметики указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;
  int і, kol(0);
  float mas[n], s(0);
  float *pm = mas;         //pm= &mas[0];
for (і = 0; і < n; i++)  
  { cout << "Введите" << і << "элемент mas" << endl;
    cin >> *pm++;
    cout << mas[i] << endl;
    if (mas[i] >0) 
    { s += mas[i]; 
      kol++; }  
  }
  cout.precision(3);
  cout << "\n Среднее арифм. полож. элементов = " << s/kol << endl;
  getch();
}



У цій програмі для введення масиву застосований покажчик *рm, а для роботи з масивом — ім’я масиву з індексом.



В останньому випадку використання покажчика *рm призвело б до помилкового результату, оскільки цей покажчик в операціях введення збільшує свою адресу (рm++) після введення чергового елемента масиву і надалі вказує на ще не введений елемент.



Наведемо четвертий варіант (Р6_7_4.СРР) програмної реалiзації прикладу:



/* Р6_7_4.СРР — использование указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;
  float mas[n], s = 0;
  float *pm = &mas[0];     //pm *= &mas[0];
 int i, kol = 0;
  for (і = 0; і < n; i++)
  { cout << "Введите" << і << "элемент mas" << endl;
    cin >> *pm; 
    if (*pm >0)
    { s += *pm; 
      kol++; 
      pm++; }  
  }
  cout.precision(3);
  cout << ”\n Среднее арифм. полож. элементов = " << s/kol << endl;
 getch();
}



## Масиви покажчиків


Подібно до інших змінних, покажчики можна групувати в масиви, кожен з елементів яких містить адресу рядка масиву даних у пам’яті. Такий спосіб дозволяє зберігати дані з рваними краями, наприклад, деяку текстову інформацію (див. рис. 6.5) Масив з «рваними» краями схожий на двовимірну таблицю, рядки якої можуть мати різну довжину. Використання масиву покажчиків (char *fio[ ]) для збереження рядків дозволяє заощаджувати пам’ять, а процес обробки рядків виконується значно швидше, бо змінюються тільки покажчики, а не вміст рядків.



Приклад 6.8. Заданий масив з рваними краями (див. рис. 6.5) Навести програмну реалізацію виведення такої інформації з використанням масиву покажчиків.
[|IMG|](/uploads/posts/2015-12/1450816903_6_3.png)



// P6_8.CPP — использование массива указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ char *fio[ ] = { "Петренко",
                   "Головко",
                   "Корж",
                   "Куц",
                   "Юшко",
                   "Плющ" };    // инициализация массива указателей
 int str;
  for (str = 0; str <=5; str++)
  cout << " stroka " << (str + 1) << " = " << *(fio + str) << endl;
  getch();        // для задержки экрана вывода результата
}



Результати виконання програми:


stroka 1 = Петренко
stroka 2 = Головко
stroka 3 = Корж
stroka 4 = Куц
stroka 5 = Юшко
stroka 6 = Плющ


Нa рис. 6.5 представлено зв’язок масиву покажчиків char *fio[ ] з відповідними текстовими рядками.



Особливістю масиву покажчиків є те, що кожний з його елементів може вказувати на масив довільної довжини. Iснуе можливість записати двовимірний масив чисел і як матрицю, і як одновимірний масив покажчиків.



 int matr[5][7];
 або
int *pmt[5];



При цьому двовимірний масив розглядається як одновимірний масив рядків, кожен елемент якого — це теж масив стовпцiв, тобто масивмасивів, тому індексування елементів матриці записуется у вигляді mas[i][j].



Звернення до елемента mas [i][j] може здійснюватися так:



          *(pm[i] +j)
          або
*(*(рm + і) + j) .



Приклад 6.9. Сформувати матрицю цілих чисел С(5,5), елементи якої обчислюються за формулою Сij = i+j. Підрахувати добуток елементiв, розташованих нижче побічної діагоналі, та обнулити ці елементи. Вивести на екран елементи, розташовані в трикутниках нижче головної та вище побічної діагоналей.



Перший варіант програмної реалізації даної задачі (див. Р6_10_1.СРР) передбачає, що матриця описується явним способом і робота ведеться з її елементами.



// Р6_9_1.СРР — программа без использования указателей
#include <iostream.h>
#include <conio.h>
const int n = 5;
int main()
{ int i, j, C[n][n];
  int Pr;          // Pr —     переменная для подсчета произведения
//------------------- формирование матрицы С[n][n]
 cout << "------ Матрица С[n][n]: \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
   { C[i][j]=i+j;
     cout << C[i][j] << " " ;
   } 
   cout << endl;
 }
/* вычисление произведения (Pr) элементов ниже побочной диагонали и их последующее обнуление */
  Pr = 1;       //начальное значение Рr
 for (і = 0; і < n; i++)
    for (j = n - і; j < n; j++)
    { Pr*= C[i][j];
      C[i][j] = 0; }
//-------------- вывод па экран полученных результатов
  cout << "\n Произведение ниже побочной диагон. = " <<Рг << endl;
  cout << "\n-------- Преобразованная матрица \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
    cout << C[i][j] << " ";
    cout << endl; }
//---------------------- вывод элементов ниже главной диагонали
  cout << "\n Элементы ниже главной диагонали ";
  for (і = 0; і < n; i++)
  { for (j=0; j<n; j++)
    if (j < i) cout << C[i][j] << " ";
    else cout << " " ;
    cout << endl;  }
//--------------------- вывод элементов выше побочной диагонали
  cout << "\n Элементы выше побочной диагонали \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
    if (j < n-1-i) cout << C[i][j] << " ";
    else cout << " ";
    cout << endl; }
   getch();
   return 0;
}



Результати обчислень:


&#8212;&#8212;-Матрица C[n]|n]:
0 1 2 3 4
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
Произведение ниже побочной диагон. = 52920000
&#8212;&#8212;- Преобразованная матрица
0 1 2 3 4
1 2 3 4 0
2 3 4 0 0
3 4 0 0 0
0 0 0 0 0
Элементы ниже главной диагонали
1
2 3
3 4 0
4 0 0 0
Элементы выше побочной диагонали
0 1 2 3
1 2 3
2 3
3



Другий варіант програмної реалізації (див. Р6_9_2.СРР) використовує масив покажчиків:



// Р6_9_2.СРР — формирование и обработка матрицы
//-------------- используется массив указателей
#include <iostream.h>
#include <conio.h>
const int n = 5;
int main()
{ int i, j, Pr, C[n][n], *pm[n];
//---------------- инициализация массива указателей
  for (і = 0; і < n; і++)
  pm[i] = &C[i][0];
//--------------- формирование матрицы С[n][n]
  cout << " Матрица C[n][n]"<< endl;
  for (i = 0; і < n; i++)
    for(j = 0; j < n; j++) 
    *(pm[i] + j) = i+j;
//------------------ вывод матрицы
 for (i = 0; i < n; i++)
  { for (j = 0; j < n; j++)
    cout << *(pm[i] + j) << " ";
cout << endl; }
/* вычисление произведения (Pr) элементов ниже побочной диагонали и их последующее обнуление */
 Pr = 1;
  for (i = 0; i < n; i++)
    for (j = n-i; j < n; j++)
    { Pr*=*(pm[i] + j);
      *(pm[i]+j) = 0; }
//------------ вывод на экран полученных результатов
 cout << endl <<" Произведение ниже побочной диагон. = " << Pr << endl;
  cout << endl << " Преобразованная матрица " << endl;
  for (і = 0; і < n; i++)
    { for (j = 0; j < n; j++) 
      cout << *(pm[i] + j) << " ";
      cout << endl; }
//----------------- вывод элементов ниже главной диагонали
cout << endl << " Элементы ниже главной диагонали"; 
  for (і=0; і < n; і++)  
  { for (j = 0; j < n; j++)
    if (j < i) cout << *(pm[i] + j) << ' ';
    else cout << " ";
    cout << endl;}
  cout << endl;
//------------ вывод элементов выше побочной диагонали
  cout << endl << " Элементы выше побочной диагонали " << endl;
  for (і = 0; і < n; і++)  
  { for (j = 0; j < n; j++)
    if (j < n-1-i) cout << *(pm[i] +j) << ' ';
    else cout << " ";
    cout << endl; }
   getch();
  return 0;
}



У розглянутій програмі для виведення матриці можна використати інший вигляд оператора виведення, наприклад:
cout << ( (j = = 0) ? &#8216;\t&#8217;: &#8216; &#8216;)<< *(pm[i] +j) << ((j= =n)? &#8216;\n&#8216;:&#8217; &#8216;);.



Ім&#8217;я двовимірної матриці є покажчиком-константою на масив покажчиків-констант, кожний з елементів якого вказуе на початок відповідного рядка матриці. Наприклад, для матриці mat[2][2] маємо:
mat [0] — покажчик-константа на нульовий рядок матриці;
mat [1] — покажчик-константа на перший рядок матриці;
mat [2] — покажчик-константа на другий рядок матриці;,
тобто:
mat [0] = = &mat [0][0];
mat [1] = = &mat [1]|0];
mat [2] = = &mat [2][0];.
Виведення матриці можна реалізувати з використанням одного з наведених нижче операторів, наприклад:
cout << mat[i][j];
cout << *(mat [і] + j);
cout << *(*(mat + і) + j);.
Приклад 6.10. Задана матриця aij (i = 1&#8230;n, j = 1&#8230;m) n = 3, m = 4, необхідно її парні елементи переписати до масиву b, а непарні — до масиву с.



Алгоритм розв’язання цієї задачі наведено у прикладі 1.6



/* Р6_10.СРР — формирование массивов четных и нечетных элементов */
// использование имени массива как указателя на его начало
#include <iostream.h>
#include <conio.h>
const int n = 3, m = 4;
void main ()
{ int a[n][m], b[m*n], c[m*n], i, j, kc = 0, kn = 0;
// kc и kn — счетчики подсчета четных и нечетних элементов
//-------------------- ввод исходной матрицы а[n][m]
  cout << " Vvod massiva a[n][m] " << endl;
  for (і = 0; і < n; i++)
    for (j = 0; j < m; j++)
    cin >> *(*(a+i)+j);
//------------ формирование массивов b[ ] и c[ ]
for (i = 0; і < n; i++)
    for (j = 0; j < m; j++)
    if (*(*(a+i)+j)%2 == 0) *(b+kc++) = *(*(a+i)+j);
    else *(c+kn++) = *(*(a+i)+j);
//—-------- вывод массива b[] — четных элементов
  cout << endl << "massiv chetn. elementov — b[ ] " << endl;
  for (і = 0; і < kc; i++) 
  cout << *(b+i) << " ";
  cout << endl;
//----------------- вывод массива c[ ] — нечетных элементов
cout << endl << "massiv nechetn. elementov — c[ ]" << endl;
  for (і = 0; і < kn; i++)
  cout << *(c+i) << " ";
  cout << endl;
//------------------  вывод исходной матрицы a[n][m] в естественном  виде
 cout << endl << "ishodny massiv";
  for (і = 0; і < n; і++)
  { cout << endl;
    for (j = 0; j < m; j++)
    cout << *(*(a+i)+j) << " "; }
   getch();
}



Результати обчислень:


Vvod massiva a[n][m]
8 2 4 -1
6 1 0 -5
2 9 3 -1
massiv chetn. elementov — b[ ] 
8 2 4 6 0 2
massiv nechetn. elementov — c[ ] 
-1 1 -5 9 3 -1
ishodny massiv
8 2 4 -1
6 1 0 -5
2 9 3 -1.



У C++ можна описати змінну, що має тип «покажчик на покажчик». Ознакою такого типу є повторення символа «\*» при описі змінної, тобто int pmt;.



Пам’ять для такої змінної не виділяється. Її треба привести до відповідного масиву. При описі покажчик на іпокажчик можна ініціювати:


int х = 20;
int *px1 = &х;
int рх2 = &рх1;
int *рхЗ = &рх2;.
Доступ до змінної х здійснюється одним з трьох, способів:
*рх1;
 px2;
 *рхЗ;.



Для доступу до пам’яті через покажчики на покажчики використовуються як символи «\*», так і індекси. Наприклад, іеквівалентими будуть такі посилання на змінну х:


*px1;               //рx1 [0];
рх2;             //рх2 [0][0];
*рхЗ;           //рхЗ [0][0][0];.




## Сортування масивів


Сортування масиву — один з найбільш розповсюджених процесів обробки даних. Завдяки йому здійснюється розміщеня об&#8217;ектів у визначеному порядку, наприклад, чисел за зростанням або за спаданням їх значень, прізвищ у алфавітному порядку тощо. Існують різні методи сортування, серед них — обмінне сортування (метод «пухирця», «шейкер-сортування), сортування вибором, сортування вставками, швидке сортування, сортування Шелла, пірамідальне сортування, сортування обчисленням адреси, сортування порозрядним групуванням тощо. Ці методи відрізняються швидкістю отримання результату, складністю і універсальністю.



Розглянемо три методи сортування: обміном, вибором та вставками. Названі методи легко описуються у формі чітких алгоритмiв і передбачають нескладну програмну реалізацію, крім того вони цікаві тим, що моделюють природну поведінку людини, яка здійснює сортування вручну. З іншого боку, вказані методи не досить ефективні і використовуються у випадках, коли необхідно відсортувати масиви невеликого розміру.



Обмінне сортування проілюструємо простим сортуванням обмiном — методом «пухирця», який здійснюється шляхом перестановки елементів за визначеним правилом. У загальному випадку алгоритм сортування за цим методом наведений у прикладі 1.4. Розглянемо його більш детально.



Нагадаємо головні складові методу «пухирця»:



* крок сортування містить перегляд елементів масиву з початку до кінця, при цьому розглядаються пари сусідніх елементів;
* елементи деякої пари міняються місцями у випадку, коли їх послідовність розташування не відповідає умові сортування (за зростанням або за спаданням).


Приклад 6.11. Упорядкувати за зростанням методом &#8220;пухирця&#8221; масив xі (і = 0&#8230;n-1), n = 5, що має значення:



x0 = 25; x1 = 37; х2 = 0; х3 = 10; х4 = 2.



Слід зауважити, що жоден метод сортування не досягає результату за один перегляд масиву, для цього застосовується, як правило, цикл у циклі.



В алгоритмі сортування за методом «пухирця» (див. рис. 6.6.) з цією метою використано зовнішній цикл (цикл кроків сортування) за параметром k та внутрішній цикл (цикл порівнянь перестановок) за параметром і. Оскільки кількість кроків сортування має бути n-1, то параметр k зовнішнього циклу змінюеться від 1 до n-1 включно. На кожному кроці сортування у циклі за параметром і відбувається порівняння пар сусідніх елементів та їх перестановка у випадку, коли пара розташована не за зростанням. Параметр і відповідає номеру елемента масиву.



Перший крок сортування (k = 1) здійснюється так:



* послідовно порівнюються пари сусідніх елементів («25» «37») і, якщо перший елемент більше за другий, вони міняються місцями, тобто на друге місце, як пухирець, «спливае» більший з двох елементів (у даному випадку елементи залишаються на своїх місцях, елемент, що «спливає», виділенні шрифтом):
* потім другий елемент («37»), більший з двох, порівнюється з третім елементом («0»), і на третє місце «спливає» більший з трьох («37»):
* далі третій елемент («37») порівнюється з четвертим елементом («10»):
* перегляд продовжується до кінця масиву, і найбільший елемент «спливе» та займе останнє місце у масиві:


[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450820334_6_4.png)
Другий крок сортування (k = 2), у результаті якого «спливає» вправо на передостаннє місце наступний найбільший елемент, дає таке розміщення елементів:



Третій крок сортування (k = 3) дозволяє розташувати наступний за величиною елемент третім справа:



І  далі останній четвертий крок сортування (k = 4) дає результат:



Сортування масивів за методом «пухирця» є найменш ефективним, середня кількість порівнянь дорівнює (n2 - n)/2. Незважаючи на це, метод залишається одним з найпопулярніших завдяки простоті реалізації.



Особливості застосування методу «пухирця»:



* алгоритми сортування, як за зростанням, так і за спаданням елементів, майже однакові, відрізняються вони тільки знаками порівняння, тобто, наприклад, замість xі > х<sub>і+1</sub> слід записати прямо протилежне — x<sub>i</sub> < х<sub>і+1</sub>
* присутність однакових елементів у масиві не додає проблем: у момент порівняння обидва елементи залишаються ні своїх місцях, а потім послідовно зміщуються по ряду та займають своє остаточне місце на сусідніх позиціях.Наведемо другий варіант програмної реалізації прикладу (див. Р6_11_2.СРР), в якому ім’я масиву використано як покажчик на його перший елемент:


/* Рr6_11 _2.СРР — сортировка одномерного массива по возрастанию методом «пузырька» */
//--------------- использование имени массива как указателя
#inchide <iostream.h>
#include <conio.h>
main( )
{ const int n = 5;
  int x[n], i, k;  int а;       /* а — рабочая переменная для перестановки местами двух элементов */
//----------- ввод исходного массива
  for (і = 0; і < n; i++)
   сіn >> *(x+i);
//----------- вывод на экран исходного массива
  cout << "\n massiv х[n] \n";
  for (i = 0; i < n; i++) 
  cout << *(x+i) << " "; 
//------------- сортировка no возрастанию
  for (k = 1; k < n; k++)       // цикл шагов сортировки
    for (і = 0; і < n-k; і++)    /* цикл сравненья элементов и их перестановки */
    if (*(x+i) > *(x+i+1))   
    { а = *(x+i);
     *(x+i) = *(x+i+1);
     *(x+i+1) = a; }
  cout << "\n Result sortirovki massiva " << endl;
  for (i=0; і < n; i++) 
  cout << *(x+i) << " ";
  getch();  
}



Приклад 6.12. Для матриці matr(5,6) знайти суми елементів кожного рядка та записати їх в одновимірний масив. Стриманий масив відсортувати за зростанням методом «пухирця».



// Р6 12.СРР - использование двумерных массивов 
/* занесение сумм элементов строк матрицы в массив и сортировка его по возрастанию методом "пузырька" */
#include <iostream.h>
#include <conio.h>
void main()
  { int matr[5][6], mas[5];      // mas[ ] — массив сумм  строк   
    int і, j, sum, stk;
//--------------------- ввод матрицы matr(5,6)
  cout << "Vvod matr[5][6] \n";
  for (і = 0; і < 5; і++)  
    for (j = 0; j < 6; j++)
    cin >> matr[i][j];
//--------------- формирование массива сумм элементов строк
  for (і = 0; sum = 0; і < 5; і++)  
  { // нахождение суммы элементов строки
    for (j = 0; j < 6; j++)
    sum += matr[i][j];
    mas[i] = sum }       //занесение суммы строки в массив
  cout << "\nMassiv summ el. strok" << endl; 
  for (і = 0; і < 5; i++) 
  cout << mas[i] << " ";
//------------------ сортировка массива сумм по возрастанию
  for (і = 1;   і < 5; і++)           // цикл шагов сортировки 
    for (j = 0; j < 5-і; j++)      // цикл сравнен. и перестан. элем.
    if (mas[j] > mas[j+1])
    { stk = mas[j];          // stk — для перестановки элементов 
      mas[j] = mas[j+1];     
      mas[j+1] = stk; }  
  cout << "\nOtsortirovanniy massiv \n";
  for (i = 0; і < 5; i++) 
  cout << mas[i] << " ";
  getch();            //задержка экрана вывода результата
}



Результати обчислень:


Vvod matr[5][6]
1 6 4 9 3 2
2 8 5 7 3 1
0 7 5 0 3 2
6 3 9 2 9 4
0 4 8 3 9 2
Massiv summ elementov strok 
25 26 21 33 31
Otsortirovanniy massiv
21 25 26 31 33


У програмі використані типові прийоми алгоритмізації - накопичення суми sum та формування робочого масиву masj, що запам&#8217;ятовує суми елементів кожного рядка матриці. Застосування цих прийомів докладно пояснене відповідно у прикладі 1.2 та прикладі 1.5. Кількість елементів створеного масиву дорівнює кількості рядків матриці. Для сортування отриманого масиву за зростанням використано сортування методом «пухирця».


[Фрагмент лекції професора Девіда Малана із курса CS50 сортування “бульбашкою”](http://cpp.dp.ua/sortuvannya-bulbashkoyu/)

Сортування за методом вибору розглянемо на прикладі.



Приклад 6.13. Упорядкувати за зростанням методом вибору вихiдний масив, що має такі значення:



x0 = 20; x1 = 1; х2 = 30; х3 = 2; х4 = 7, х5 = 5.



Схему алгоритму та програму реалізації даної задачі наведено на рис. 6.7.



Процес сортування за зростанням здійснюється за кроками. Позначимо номер кроку сортування параметром і. На кожному кроці шукається найменший елемент, що міняється місцями з елементом, номер якого збігається з номером кроку і.



Нульовий крок сортування (і = 0):



у процесі розгляду елементів масиву, починаючи з першого, знаходять найменший елемент («1») і розташовують його на місце першого елемента, а перший («20») — на місце мінімального. У результаті найменший елемент масиву потрапляє
![null](/uploads/posts/2015-12/1450816903_6_3.png)
на нульову позицію, тобто на перше місце зліва (підкресленi елементи, що переставляються):


![null](http://cpp.dp.ua/uploads/posts/2015-12/1450820334_6_4.png)



  Перший крок сортування (і = 1):



наступний найменший елемент («2»)знаходять у частинi масиву, що починається з першої позиції. Він міняється місцями з другим елементом («20»), тобто другий за значенням елмент («2») розташується на першій позиції, а саме на другому місці зліва:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450820924_6_4_1.png)



Другий крок сортування (і = 2):
третій за значенням елемент («5») знайдемо у масиві, починаючи з другої позиції («З0»), та поміняємо його місцем з елементом  масиву, що розташувався на другій позиції:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821131_6_4_2.png)



Подальші кроки сортування дають такі перетворення: третій крок сортування (і = 3):


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821231_6_4_3.png)



Четвертий крок сортування (і=4):


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821238_6_4_4.png)



У результаті маємо відсортований за зростанням масив:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821258_6_4_5.png)



Загальна кількість дій алгоритму сортування за методом вибору дорівнює (n2/4 + 3*n) операціям.


[Фрагмент лекції професора Девіда Малана із курса CS50 сортування вибором](http://cpp.dp.ua/sortuvannya-vyborom/)

Сортування за методом вставки полягає в тому, що на кожному кроці відбувається вставка елемента у відсортований масив. Розглянемо цей метод на конкретному прикладі.



Приклад 6.14. Упорядкувати за зростанням (за спаданням) методом  вставки масив аі (і = 0&#8230;n-1), n = 6, що має такі значення:



a0 = 4; а1 = 13; a2 = -3; а3 = 6; a4 = _8, a5 = 24.



Схему алгоритму та програму реалізації цієї задачі наведено на рис. 6.8.
[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450906389_6_4_9.png)
Сутність алгоритму сортування за методом вставки:



* якщо j (а<sub>0</sub>&#8230;а<sub>j</sub><sub>-1</sub>) елементів масиву а відсортовані за зростанням, а елемент a<sub>j</sub> має довільне значення, потрібно порівнювати цей елемент по черзі з елементами а<sub>j</sub><sub>-1</sub>, a<sub>j</sub><sub>-2</sub>,…, доки для a<sub>j</sub> не знайдеться місце у відсортованому масиві. При цьому всі розглянуті елементи a<sub>j</sub><sub>-1</sub>, a<sub>j-2</sub> ,&#8230;,що будуть за значенням більш ніж a<sub>j</sub> , мають переміститися на одну позицію вправо;
* у випадку, коли елемент-вставка aj виявиться більше за значенням , ніж а<sub>j</sub><sub>-1</sub>, елемент a<sub>j</sub> залишиться на своєму місці. Якщо a<sub>j</sub> буде менше всіх елементів а<sub>0</sub>&#8230;а<sub>j</sub><sub>-1</sub>, то всі елементи мають бути переміщені на одну позицію вправо, a a<sub>j</sub> займе місце j = 0. Що при переміщенні вправо не загубити значення елемента-вставки a<sub>j</sub>, потрібно завчасно зберегти його в робочій змінній (rab)


У програмі параметр і зовнішнього циклу відповідає за номер елемента-вставки, тому на першому кроці (і = 1) вважаємо що відсортований масив, до якого вставляється елемент rab = aj складається тільки з одного елемента, на наступному кроці (і  = 2) маємо відсортований масив з двох елементів, а вставляємо до нього елемент а2 і так далі.



У внутрішньому циклі програми за параметром j відбувається порівняння елемента-вставки rab з елементами відсортованого масиву і переміщення цих елементів вправо, якщо за значенням вони більші, ніж rab. Безпосередньо вставка відбувається у зовнішньому циклі: aj = rab.



З розглянутих методів сортування цей метод — найефективніший, середня кількість операцій приблизно дорівнює n2 / 4. Наведемо ще один варіант (див. Р6_14_2.СРР) програмної реалізації сортування масиву за спаданням елементів з використанням методу вставки, в якій використано покажчики та застосовано цикл while для пошуку мiсця елемента вставки.



//Р6_14_2.СРР — сортировка методом вставки (по убыванию)
//---------------------- использование указателей
#include <iostream.h> 
#include <conio.h>
const int n=6; 
main ( )  
{ int a [n], i, j, rab;
  int *pmas; 
   pmas = a;      // pmas - &a[0]; — указатель на начало массивам
 cout << "* Введите 6 элементов массива" << endl;
 for (і = 0; і < n; i++)
   cin >> *pmas++; 
  pmas = a;      //pmas -= n; — указатель на начало массивa
  for (і = 1; і < n; і++)
   { rab= *(pmas + і); 
    j = і;      
    while (j > 0 && rab > *(pmas + j-1))    
    { *(pmas + j) = *(pmas + j-1); 
       j-- }      
  *(pmas + j) = rab; }      
  cout << "Отсортированный массив по убыванию" << endl;      
  for (і = 0; і < n; i++) 
  cout << *(pmas + i) << " ";          
 getch();  
}



Результати виконання програми:



Введите 6 элементов массива 
4 12 -3 6 -8 24
Отсортированный массив по убыванию
24 12 6 4 -3 -8


[Фрагмент лекції професора Девіда Малана із курса CS50 сортування вибором](http://cpp.dp.ua/sortuvannya-vstavkoyu/)

Приклад 6.15. З двох впорядкованих за зростанням масивів ai (i = 0...n-1) і bj (j = 0&#8230;m-1) сформувати третій, також впорядкований, масив без додаткового сортування (n = 8, m = 12).



Алгоритм злиття двох відсортованих масивів (див. рис. 6.9) починається з порівняння перших елементів відповідних масивiв а і b. За лічильником і будемо вибирати елементи з масиву а, за лічильником  j — з масиву b, а за параметром  k — заносити елементи до масиву с. У масив с заноситься менший з елементів, що порівнюються, а далі в порівнянні бере участь наступний елемент того масиву, елемент якого вже записаний до с. Ця процедура повторюється, доки один з масивів не закiнчиться. Наприкінці слід тільки переписати до масиву с всі елементи іншого масиву, що залишилися.
[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450821386_6_4_8.png)



/* Р6_15.СРР — из двух массивов, отсортированных по возрастанию, сформировать третий */
#include <iostream.h>
#include <conio.h>
const int n=8, m=12;
void main()
{ int a[n], b[m], c[n+m];
  int i, j, k, 1;
//--------------- ввод двух отсортированных массивов
cout << "Vvedite 2 otsortirovanih massiva" << endl;
  for (i = 0; і < n; i++) 
  cin >> a[i];
  for (j = 0; j < m; j++)  
  cin >> b[j];
//------------------- слияние массивов a и b в массив с
 for (і = 0, j = 0, к = 0; і < n && j < m; k++)  
  if (a[i] < b[j]) c[k] = a[i++];  
  else c[k] = b[j++];  
  if (i = = n)    
  for (l = k; l < n+m; l++) 
  c[l] = b[j++];  
  else 
  for (l = k; l < n+m; l++) 
  c[l] = a[i++];
//-------------- вывод полученного массива с
  cout << "Rezult — massiv c" << endl;
  for (і = 0; і < n+m; i++) 
  cout << c[i] << " ";
  getch();
}



Результати обчислень:


Vvedite 2 otsortirovanih massiva
1 4 11 17 33 54 60 62
1 5 9 14 15 19 20 23 44 48 72 80
Rezult — massiv c
1 2 4 5 9 11 14 15 17 19 20 23 33 44 48 54 60 62 72 80
Ефективний метод сортування великих масивів — швидке cортування — розглянутий у підрозділі «Рекурсивні функції»




## Динамічні масиви


В основній пам’яті дані можуть зберігатися двома способами



* пам’ять виділяється або в сегменті стека і залишається закріпленою до завершення виконання конкретної функції, або виділяється в сегменті даних на весь час виконання програми;
* пам’ять виділяється в міру потреби (динамічне виділення  пам’яті).


Слід зазначити, що всі приклади, розглянуті раніше, демонструють роботу з даними, які зберігаються першим способом.



Динамічна пам’ять — це вільна пам’ять, у якій під час виконання програми можна виділяти місце залежно від потреб користувача. Доступ до виділених ділянок динамічної пам&#8217;яті, що називаються динамічними змінними, здійснюється тільки через покажчики. Час існування динамічних змінних — від початку створення до кінця програми або до явного звільнення пам’яті. У мові C++ застосовують два способи роботи з динамічною пам’яттю. Перший з них дістався в спадщину від мови С і використовує сукупність функцій malloc(), другий — працює з операціями new та delete, які здійснюють динамічний розподіл і скасування з вищим пріоритетом, ніж інші функції.



Оператор new виділяє пам’ять і повертає її адресу. За допомогою оператора delete відбувається звільнення пам’яті, на яку вказує змінна-покажчик.



Загальна форма запису оператора new:



змінна-покажчик = new тип змінної;.



Оператор delete має вигляд:



delete [ ] змінна-покажчик; .



Динамічні масиви створюють за допомогою операції new, при цьому необхідно вказати їх тип і розмірність. Наприклад, Для одновимірного масиву дійсних чисел, що має 100 елементів, треба записати:



int n = 100;



 float *р = new float[n]; — змінна-покажчик на float виділяє у динамічній пам’яті ділянку для розміщення 100 елементів дійсного типу.



Слід пам’ятати, що динамічні масиви при створенні не можна ні ініціювати, ні обнуляти.



Приклад 6.16. З використанням динамічної пам’яті обробити вiдомість успішності групи студентів з дисципліни &#8220;Програмування&#8221; підрахувавши середній бал групи і кількість відмінників.



/* P6_16.CPP использование динамической памяти при обработке одномерного массива */
#include <iostream.h>
#include <conio.h>
#include <math.h>
main ( )
{ const int n = 14;                // количество студентов
  int *mas;                         // объявление указателя на массив
  int і, k = 0;                      // k — количество отличников
  float s = 0;                      // s — сумма оценок группы
  mas = new int [n];             //выделение динамической памяти
cout << " Ввод оценок " << endl;
  for (і = 0; і < n; і++)  
  сіn >> mas[i];
//---------------- подсчет суммы оценок и количества отличников
  for (і = 0; і < n; і++)
  { s = s + mas[i];
    if (mas[i] == 5) 
    k = k+1; }
  cout << endl; 
  cout.precision(3);
  cout << "Средний балл = " << s/n << endl;
  cout << "Количество отличников = " << k << endl;
  getch (); 
  delete[ ]mas;       // освобождение динамической памяти
}



Результати обчислень:


Ввод оценок
33345343245333
Средний балл = 3.43
Количество отличников = 2



У цій програмі змінна s служить для обчислення суми oцiнок групи, а змінна k — для підрахунку кількості відмінників. Перед обчисленням треба надати цим змінним початкове нульове значення (накопичення суми і кількості пояснено у прикладах 1.1-1.2).



При створенні динамічного багатовимірного масиву необхiдно в операції new вказати всі його розмірності (перший може бути змінною), наприклад:
int n = 5; // n — количество строк
int m = (int ) new int [n][5];.



Розглянемо більш універсальний і безпечний спосіб видiлення динамічної пам’яті під двовимірний масив, коли обидвi йгого розмірностізадаються на етапі виконання програми. Наприклад, розподіл динамічної пам’яті для матриці, що має n рядкiв і m стовпців та елементи цілоготипу, можна здійснити так:



int n, m;
cout << &#8221; Введите количество строк и столбцов: &#8220;;
cin >> n >> m;
int a = new int *[n]; — оголошення змінної тип «покажчи на покажчик на int» і виділення пам’яті для масиву покажчиків на рядки матриці;
for (int і = 0; і < n; і++)
a[і] = new int [m]; — кожному елементу масиву покажчиків на рядки присвоюється адреса початку ділянки пам’яті, виділеної для рядка матриці.



Наочно це представлено на рис. 6.10.
[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450895538_6_5.png)
Звільнення пам’яті з-під масиву будь-якої кількості вимірів виконується за допомогою операції delete[].



Приклад 6.17. З використанням динамічної пам’яті створити програму обчислення матриці С за формулою:



С [n][q] = A[n][m] * B[m][q].



Згідно з умовою, елемент матриці C[n][q] дорівнює сумі добутків елементів відповідного рядка матриці A[n][m] на елементи відповідного стовпця матриці



У запропонованій програмі для обчислення елементів добутку матриць організовано три вкладених цикли: цикл переборі рядків матриці А, цикл перебору стовпців матриці В, а також цикл накопичення суми для одержання елемента матриці С. Для виділення динамічної пам’яті під двовимірні масиви A[n][m], B[m][q] і С [n][q] скористаємося розглянутим вищі способом.



/* Р6_17.СРР — использование динамической памяти при работе с матрицами */
#include <iostream.h>
#include <math.h>
#include <conio.h>
main ( )
{ int і, j, k; 
  int n, m, q;
  cout << " Введите размерности матриц: \n";
  cout << " n = " ; 
  cin >> n;
  cout << " m = " ; 
  cin >> m;
  cout << " q = " ; 
  cin >> q;
//----------------- создание динамических массивов
/* выделение динамической памяти под массивы указателей и инициализация массивов указателей */
  int С = new int *[n];
  for (int і = 0; і < n; і++)
  C[i] = new int [q];
  int A = new int *[n];
  for (int і = 0; і < n; i++)
  A[i] = new int [m];
  int B = new int *[m];
  for (int і = 0; і < m; i++)
  B[i] = new int [q];
//------------------------------ ввод матриц A[n][m] и B[m][q]
 cout<<"\n Ввод матрицы A[n][m] \n";
  for (і = 0; і < n; і++)
    for (j = 0; j < m; j++) 
    сіn >> *(А[i] + j);
    cout << "\n Ввод матрицы B[m][q] \n”;
  for (i = 0; і < m; i++) 
    for (j = 0; j < q; j++) 
    cin >> *(B[i] + j);
//----------------------- вычисление матрицы C[n][q] = A[n][m]*B[m][q]
  for (і = 0; і < n; i++)  // перебор строк матрицы A[n][m]
    for (k = 0; k<q; k++) //перебор столбцов матрицы B[m][q]
    { C[i][k] = 0; 
      for (j = 0; j < m; j++)
      C[i][k] += (A[i][j]* B[j][k]); // определение элемента C[i][k]
    }//-------------------- вывод на экран матрицы С[n][q]
  cout << "\n Матрица C[n][q] = A[n][m] * B[m][q] \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < q; j++)  
    cout << *(C[i] + j) << " ";
    cout << endl;}
  delete [ ]A; 
  delete [ ]B; 
  delete [ ]C;   // освобождение памяти
 getch (); 
}



Результати обчислень:


Введите размерности матриц:
n = 4 
m = З 
q = 5
Ввод матрицы A[n][m]
1 1 1
3 3 3
2 2 2
4 4 4
Ввод матрицы B[m][q]
8  8  8  8  8
7  7  7  7  7
5  5  5  5  5
Матрица C[n][q] = A[n][m] * B[m][q]
20 20 20 20 20
60 60 60 60 60
40 40 40 40 40
80 80 80 80 80


