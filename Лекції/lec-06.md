# Покажчики у С++

## Перелік лекцій

1.  [Склад мови С++](lec-01.md)
2.  [Дані та операції](lec-02.md)
3.  [Організація введення-виведення даних](lec-03.md)
4.  [Основні оператори С++](lec-04.md)
5.  [Масиви у С++](lec-05.md)
6.  [Покажчики у С++](lec-06.md)
7.  [Дані символьного типу](lec-07.md)
8.  [Дані типу структура](lec-08.md)
9.  [Функції](lec-09.md)
10. [Робота з файлами](lec-10.md)
11. [Системні бібліотеки WinAPI32](lec-11.md)
12. [Обробка файлів за допомогою WinAPI32](lec-12.md)
13. [Об'єктно-орієнтоване програмування. Класи](lec-13.md)
14. [Методи та властивості. Екземпляри класу](lec-14.md)
15. [Паралельні обчислення за стандартом OpenMP](lec-15.md)
16. [Паралельні обчислення з бібліотекою MPI](lec-16.md)

## Покажчики та масиви


**Покажчики** — це змінні, котрі містять адресу пам’яті, розподіленої для об’єкта відповідного типу. Усі змінні, розглянуті до цього, зберігали якісь значення (дані). Ці дані могли бути різних типів: символьного, цілого, дійсного тощо. При оголошенні змінної-покажчика слід вказати тип даних, адресу яких буде містити змінна, та ім’я покажчика з символом «*».



Загальний формат опису покажчика має вигляд:


>
**тип *ім’я;**



де **тип** — тип значень, на який вказує покажчик;
**ім’я** — ім’я змінної-покажчика;
«*» — операція над типом, що читається «покажчик на тип».



Наприклад:



int *рn; // покажчик на ціле значення;
float *pf1, *pf2; // два покажчики на дійсні значення.



Покажчики не прив’язують дані до якого-небудь визначеного імені змінної і можуть містити адреси будь-якого неіменованого значення. Існує адресна константа **NULL**, що означає порожню адресу.



Слід нагадати, що мова C++ налічує лише дві операції, які стосуються адрес змінних, а саме:



**«&amp;»** — **операція взяття адреси** («адреса значення»);



**«*»** — **операція розіменування** («значення за адресою»).



Операція взяття адреси **«&amp;»** застосовується разом зі змінною і повертає адресу цієї змінної. Операція розіменування «*» використовується разом з покажчиками і вилучає значення, на яке вказує змінна-покажчик, розташована безпосередньо після символа «*».



Оголошення покажчиків можна здійснити одним з таких способів:



<тип> *ptr;
<тип> *ptr = <змінна-покажчик>;
<тип> *ptr = &amp;<ім’я змінної>;



Наприклад:
**int *ptx, b; float у;** — оголошені змінна-покажчик **ptx** та змінні **b і у**;



**float *sp = &amp;у;** — покажчику **sp** присвоюється адреса змінної **у**;



**float *р = sp;** — покажчику **р** присвоюється значення (адреса значення), яке міститься в змінній **sp**, тобто адреса змінної **у**.



При оголошенні покажчиків символ «*» може знаходитися перед ім’ям покажчика або відразу після оголошення типу покажчика і поширювати свою дію тільки на одну змінну-покажчик, перед якою він записаний:



**long *pt;   long*Uk;   int *ki, x, h; **— оголошення описів.



За потреби для опису покажчика на комірку довільного типу замість ідентифікатора типу записується слово **void**, а саме:



**void *р, *pt;** — опис двох покажчиків на довільний тип даних.



**Перед використанням покажчика у програмі його обов&#8217;язково необхідно ініціювати**, іншими словами, необхідно присвоїти адресу якого-небудь даного, інакше можуть бути непередбачені результати.



Для одержання доступу до значення змінної, адреса якої зберігається в покажчику, досить у відповідному операторі програми записати ім’я покажчика з символом «*» — здійснити операцію розіменування.



Розглянемо фрагмент програми з поясненнями:



**int *р, *р1; **— оголошені два покажчики на комірку пам’яті типу **int**;



**int х = 12, у = 5, m[7]; **— оголошені змінні **х**, **у** і масив **m**, змінні ініційовані;



**р = &amp;у; **     // р (&amp;у); — покажчику **р** присвоєна адреса змінної **у**.



Якщо для цього фрагмента програми записати оператор виведення у вигляді



**cout << &#8220;Адрес р &#8221; << р << &#8220;Значение по этому адресу = &#8221; << *р;,**



то виведеться адреса комірки пам’яті, де записана змінна** у** і значення цієї змінної (**тобто 5**).



Використовуючи запис** х = *р;**, одержимо **х = 5**, тому щo ***р = у = 5;**.



Змінити величину параметра **у** можна так:



у = 10;          // *Р= 10;
*р = *р+5;    //у +=5;.



Остання операція означає збільшення значення змінної у цiлого типу на **5**, тобто **у= 15**.



При ініціюванні покажчиків їм можна присвоювати або адресу об’єкта (змінної), або адресу конкретного місця пам’яті (масиву), або число 0 (нуль), а саме:



int *pt = (char *) 0x00147; // — присвоюється адреса комірки;
int *arrpt = new int [10]; // — визначається початкова адреса розміщення динамічного масиву;
char *р = 0; // — здійснюється ініціювання нулем.



Оскільки покажчики — це спеціальні змінні, то в операціях з іншими покажчиками вони можуть використовуватися без символа «*», тобто без розкриття посилання, наприклад:



float *pt1, *pt2, х=15, m[5];
pt1 = &amp;x; 
pt2 = pt1;
pt1 = m;         //pt1 = &amp;m[0];
де  m — ім’я масиву, що розглядається як спеціальний покажчик-константа.



**Приклад 6.6.** Написати ілюстраційну програму з використанням покажчиків.



// P6_6.CPP — применение указателей 
#include <iostream.h>
#include <conio.h>
int main ( )
{ int x = 10;
  int *px (&amp;x);   // int *px = &amp;x;
cout << "x =" << x << endl; 
  cout << "*px =" << *px << endl;
  x *= 2;          //x=x*2;
  cout << "Новое значение *px = " << *px << endl;*
  px += 2;       // *px=*px + 2;
  cout << "Результат *px, т. e. x = " << x << endl;
  getch();     //задержка экрана
}



Результат виконання програми:


х = 10 
*рх = 10
Новое значение *рх = 20 
Результат *рх, т. е. х = 22



Для змінної-покажчика існує своя адреса і тому будуть до цільними записи:



int *pt1, *pt2;



**pt1 = (int*) &amp;pt2;** — покажчику **pt1** присвоюється адреса пам&#8217;ятi де розташована змінна **pt2**.



Це має сенс у випадку, коли



int у, *pt1, *pt2 = &amp;у;
pt1 = (int*) &amp; pt2;



Обмеження на застосування операції взяття адреси:



* не можна визначати адресу літеральної константи (оскільки для неї не виділяється комірка пам’яті), тобто такий запис, як **vp = &amp;345;** — неприпустимий;
* не можна визначати адресу результату арифметичного виразу, тобто запис **vp = &amp;(x + y);** теж неприпустимий.


**Дозволені операції для змінних-покажчиків:**



* операція розіменування «*»;
* операція взяття адреси «&amp;»;
* операція присвоювання «=»;
* операції інкремент «++» і декремент « &#8211;»;
* операції додавання «+» і віднімання «-»;
* операції відношення (порівняння) покажчиків однакового типу: «==», «!=», «<», «<=», «>», «>=».


У мові C++ масиви і покажчики зв’язані між собою: **ім’я масиву визначається як покажчик-константа на початковий (нульовий)елемент масиву.** Так, наприклад, при оголошенні одновимірного масиву у вигляді **int mas [20];** його ім’я **mas** &#8211; покажчик на адресу початкового елемента масиву **&amp;mas[0]**.



Існує два способи доступу до елементів масиву:



* з використанням індексу елемента масиву, наприклад, **mas[2]** або **mas[i];**
* з використанням адресного виразу, тобто виразу з покажчиком на масив, наприклад, ***(mas + 2)** або ***(mas + і)**.


Ім’я покажчика на масив можна записати так:



int mas [20];
int *ptr1;
ptr1 = mas;      //ptr1 = &amp;mas[0];,



тут вирази **&amp;mas[0] і mas** — еквівалентні.



Оскільки в комп’ютері для масивів завжди є суцільний блок комірок пам’яті, в яких розташовуються їх елементи, то адресу наступного елемента **mas[1]** можна вказати шляхом збільшення покажчика на **1**, а саме:



**р = &amp;mas[0];**



**р++;           ** //р=р  + 1;



Таким чином, адреса **і**-го елемента визначається як **р + і**. При цьому з урахуванням типу масиву і відведеної кількості байтів для кожного його елемента автоматично виконується операція збiльшення адреси, тобто:



**адреса х[і] = адреса х[0] + i*sizeof (тип); **.



Слід зауважити, що **для покажчиків, які посилаються на елементи масивів різних типів, результат арифметичних операцій і операцій відношення невизначений.**



До двох покажчиків **р1 і р2**, що вказують на елементи одного масиву, застосовують операції відношення: «==», «!=», «<», «<=», «>», «>=». При цьому значення покажчиків розглядаються як цілі числа, а результат порівняння дорівнює** 0** ( »неправда») або **1** («істина»). Так, відношення вигляду **р1<р2** є «істина», якщо **р1** указує на більш ранній елемент, ніж **р2**. Будь-який покажчик можна порівняти з нулем.



В арифметиці з покажчиками можна використовувати адресу неіснуючого «наступного за масивом» елемента. До покажчиків можна додавати або віднімати від них цілу величину.



В обох випадках результатом операції буде покажчик на вихідний тип, значення якого на вказане число елементів більше або менше вихідного. Тобто, якщо до покажчика **р** можна додати деяку цілу величину **n**, а саме: **р + n**, то цей вираз визначає ділянку об’єкта, що займає **n**-не місце після об’єкта, на який вказує **р**, при цьому **n** автоматично збільшується на коефіцієнт, що дорівнює відповідній довжині об’єкта. Наприклад, якщо **int** займає 4 байти, то цей коефіцієнт дорівнює чотирьом.



Допускається також операція віднімання покажчиків, що вказують на елементи одного масиву. Так, якщо **р1 < р2**, то **р2 &#8211; р1 + 1** — це число елементів масиву від **р1** до **р2** включно.



Наведемо приклади програм роботи з покажчиками.
**Приклад 6.7.** Обчислити середнє значення додатних елементів одновимірного масиву.



Розглянемо перший варіант програмної реалізації цієї задачі **(див. Р6_7_1.СРР)**.



/* Р671.СРР — вычисление среднего значения положительных элементов массива */
//---------------- программа без использования указателей
#include <iostream.h>
#include <conio.h>
main( )
{ const int n = 10;
  float mas[n], s = 0;
  int i, kol = 0;
  cout << "Ввод массива " << endl;
  for(i =0; і < n; i++)
    cin >> mas[i]; 
      for(i = 0; і < n; i++)   
        if (mas[i] > 0)  
{ s += mas[i];           //накопление суммы
          kol++;  //подсчет положительных елементов
        }
 cout.precision(3 ) ; 
  cout << "Средн. арифм. полож. элементов = " << s/kol << endl; 
 getch();         //задержка экрана вывода резулътата
}



Результати виконання програми:


Ввод массива
1.56 -4.78 6.5 7.89 -3.6 9.45 7.4 -8.43 9.3 -10.2
Средн. арифм. полож. элементов = 7.02



Використовуючи ім’я масиву як покажчик на початок масиву (перший елемент), можна навести другий варіант програми **(див. Р6_7_2.СРР)**:



// Р6_7_2.СРР - использование имени массива как указателя
#indude <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;  
  float mas[n], s;  
  int i, kol = 0;
  for (і = 0, s = 0; і < n; i++)
  { сіn >> *(mas+i);
    if (*(mas+i) > 0)
     { s += *(mas+i);
       kol++; }  
  } 
  cout.precision(3); 
  cout <<"\n Среднее арифм. полож. элементов = " << s/kol << endl; 
  getch();
}



Якщо описати покажчик і зв’язати його з масивом (адресувати на початок масиву), то з використанням арифметики покажчиків можна написати третій варіант **(див. Р6__7_З.СРР)** цiєї програми.



// Р6_7_3. СРР — использование арифметики указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;
  int і, kol(0);
  float mas[n], s(0);
  float *pm = mas;         //pm= &amp;mas[0];
for (і = 0; і < n; i++)  
  { cout << "Введите" << і << "элемент mas" << endl;
    cin >> *pm++;
    cout << mas[i] << endl;
    if (mas[i] >0) 
    { s += mas[i]; 
      kol++; }  
  }
  cout.precision(3);
  cout << "\n Среднее арифм. полож. элементов = " << s/kol << endl;
  getch();
}



У цій програмі для введення масиву застосований покажчик ***рm**, а для роботи з масивом — ім’я масиву з індексом.



В останньому випадку використання покажчика ***рm** призвело б до помилкового результату, оскільки цей покажчик в операціях введення збільшує свою адресу **(рm++)** після введення чергового елемента масиву і надалі вказує на ще не введений елемент.



Наведемо четвертий варіант** (Р6_7_4.СРР) **програмної реалiзації прикладу:



/* Р6_7_4.СРР — использование указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;
  float mas[n], s = 0;
  float *pm = &amp;mas[0];     //pm *= &amp;mas[0];
 int i, kol = 0;
  for (і = 0; і < n; i++)
  { cout << "Введите" << і << "элемент mas" << endl;
    cin >> *pm; 
    if (*pm >0)
    { s += *pm; 
      kol++; 
      pm++; }  
  }
  cout.precision(3);
  cout << ”\n Среднее арифм. полож. элементов = " << s/kol << endl;
 getch();
}



## Масиви покажчиків


Подібно до інших змінних, покажчики можна групувати в масиви, кожен з елементів яких містить адресу рядка масиву даних у пам’яті. Такий спосіб дозволяє зберігати дані з рваними краями, наприклад, деяку текстову інформацію (**див. рис. 6.5**) Масив з «рваними» краями схожий на двовимірну таблицю, рядки якої можуть мати різну довжину. Використання масиву покажчиків (**char *fio[ ]**) для збереження рядків дозволяє заощаджувати пам’ять, а процес обробки рядків виконується значно швидше, бо змінюються тільки покажчики, а не вміст рядків.



**Приклад 6.8.** Заданий масив з рваними краями (**див. рис. 6.5**) Навести програмну реалізацію виведення такої інформації з використанням масиву покажчиків.
[|IMG|](/uploads/posts/2015-12/1450816903_6_3.png)



// P6_8.CPP — использование массива указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ char *fio[ ] = { "Петренко",
                   "Головко",
                   "Корж",
                   "Куц",
                   "Юшко",
                   "Плющ" };    // инициализация массива указателей
 int str;
  for (str = 0; str <=5; str++)
  cout << " stroka " << (str + 1) << " = " << *(fio + str) << endl;
  getch();        // для задержки экрана вывода результата
}



Результати виконання програми:


stroka 1 = Петренко
stroka 2 = Головко
stroka 3 = Корж
stroka 4 = Куц
stroka 5 = Юшко
stroka 6 = Плющ


Нa рис. 6.5 представлено зв’язок масиву покажчиків char *fio[ ] з відповідними текстовими рядками.



Особливістю масиву покажчиків є те, що кожний з його елементів може вказувати на масив довільної довжини. Iснуе можливість записати двовимірний масив чисел і як матрицю, і як одновимірний масив покажчиків.



 int matr[5][7];
 або
int *pmt[5];



При цьому двовимірний масив розглядається як одновимірний масив рядків, кожен елемент якого — це теж масив стовпцiв, тобто масивмасивів, тому індексування елементів матриці записуется у вигляді **mas[i][j]**.



Звернення до елемента **mas [i][j]** може здійснюватися так:



          *(pm[i] +j)
          або
*(*(рm + і) + j) .



**Приклад 6.9.** Сформувати матрицю цілих чисел **С(5,5),** елементи якої обчислюються за формулою **Сij = i+j**. Підрахувати добуток елементiв, розташованих нижче побічної діагоналі, та обнулити ці елементи. Вивести на екран елементи, розташовані в трикутниках нижче головної та вище побічної діагоналей.



Перший варіант програмної реалізації даної задачі (**див. Р6_10_1.СРР**) передбачає, що матриця описується явним способом і робота ведеться з її елементами.



// Р6_9_1.СРР — программа без использования указателей
#include <iostream.h>
#include <conio.h>
const int n = 5;
int main()
{ int i, j, C[n][n];
  int Pr;          // Pr —     переменная для подсчета произведения
//------------------- формирование матрицы С[n][n]
 cout << "------ Матрица С[n][n]: \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
   { C[i][j]=i+j;
     cout << C[i][j] << " " ;
   } 
   cout << endl;
 }
/* вычисление произведения (Pr) элементов ниже побочной диагонали и их последующее обнуление */
  Pr = 1;       //начальное значение Рr
 for (і = 0; і < n; i++)
    for (j = n - і; j < n; j++)
    { Pr*= C[i][j];
      C[i][j] = 0; }
//-------------- вывод па экран полученных результатов
  cout << "\n Произведение ниже побочной диагон. = " <<Рг << endl;
  cout << "\n-------- Преобразованная матрица \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
    cout << C[i][j] << " ";
    cout << endl; }
//---------------------- вывод элементов ниже главной диагонали
  cout << "\n Элементы ниже главной диагонали ";
  for (і = 0; і < n; i++)
  { for (j=0; j<n; j++)
    if (j < i) cout << C[i][j] << " ";
    else cout << " " ;
    cout << endl;  }
//--------------------- вывод элементов выше побочной диагонали
  cout << "\n Элементы выше побочной диагонали \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
    if (j < n-1-i) cout << C[i][j] << " ";
    else cout << " ";
    cout << endl; }
   getch();
   return 0;
}



Результати обчислень:


&#8212;&#8212;&#8211;Матрица C[n]|n]:
0 1 2 3 4
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
Произведение ниже побочной диагон. = 52920000
&#8212;&#8212;&#8211; Преобразованная матрица
0 1 2 3 4
1 2 3 4 0
2 3 4 0 0
3 4 0 0 0
0 0 0 0 0
Элементы ниже главной диагонали
1
2 3
3 4 0
4 0 0 0
Элементы выше побочной диагонали
0 1 2 3
1 2 3
2 3
3



Другий варіант програмної реалізації (**див.** **Р6_9_2.СРР**) використовує масив покажчиків:



// Р6_9_2.СРР — формирование и обработка матрицы
//-------------- используется массив указателей
#include <iostream.h>
#include <conio.h>
const int n = 5;
int main()
{ int i, j, Pr, C[n][n], *pm[n];
//---------------- инициализация массива указателей
  for (і = 0; і < n; і++)
  pm[i] = &amp;C[i][0];
//--------------- формирование матрицы С[n][n]
  cout << " Матрица C[n][n]"<< endl;
  for (i = 0; і < n; i++)
    for(j = 0; j < n; j++) 
    *(pm[i] + j) = i+j;
//------------------ вывод матрицы
 for (i = 0; i < n; i++)
  { for (j = 0; j < n; j++)
    cout << *(pm[i] + j) << " ";
cout << endl; }
/* вычисление произведения (Pr) элементов ниже побочной диагонали и их последующее обнуление */
 Pr = 1;
  for (i = 0; i < n; i++)
    for (j = n-i; j < n; j++)
    { Pr*=*(pm[i] + j);
      *(pm[i]+j) = 0; }
//------------ вывод на экран полученных результатов
 cout << endl <<" Произведение ниже побочной диагон. = " << Pr << endl;
  cout << endl << " Преобразованная матрица " << endl;
  for (і = 0; і < n; i++)
    { for (j = 0; j < n; j++) 
      cout << *(pm[i] + j) << " ";
      cout << endl; }
//----------------- вывод элементов ниже главной диагонали
cout << endl << " Элементы ниже главной диагонали"; 
  for (і=0; і < n; і++)  
  { for (j = 0; j < n; j++)
    if (j < i) cout << *(pm[i] + j) << ' ';
    else cout << " ";
    cout << endl;}
  cout << endl;
//------------ вывод элементов выше побочной диагонали
  cout << endl << " Элементы выше побочной диагонали " << endl;
  for (і = 0; і < n; і++)  
  { for (j = 0; j < n; j++)
    if (j < n-1-i) cout << *(pm[i] +j) << ' ';
    else cout << " ";
    cout << endl; }
   getch();
  return 0;
}



У розглянутій програмі для виведення матриці можна використати інший вигляд оператора виведення, наприклад:
**cout << ( (j = = 0) ? &#8216;\t&#8217;: &#8216; &#8216;)<< *(pm[i] +j) << ((j= =n)? &#8216;\n&#8216;:&#8217; &#8216;);.**



**Ім&#8217;я двовимірної матриці є покажчиком-константою на масив покажчиків-констант, кожний з елементів якого вказуе на початок відповідного рядка матриці.** Наприклад, для матриці **mat[2][2]** маємо:
**mat [0]** — покажчик-константа на нульовий рядок матриці;
**mat [1]** — покажчик-константа на перший рядок матриці;
**mat [2]** — покажчик-константа на другий рядок матриці;,
тобто:
**mat [0] = = &amp;mat [0][0];**
**mat [1] = = &amp;mat [1]|0];**
**mat [2] = = &amp;mat [2][0];.**
Виведення матриці можна реалізувати з використанням одного з наведених нижче операторів, наприклад:
**cout << mat[i][j];**
**cout << *(mat [і] + j);**
**cout << *(*(mat + і) + j);.**
**Приклад 6.10.** Задана матриця **aij (i = 1&#8230;n, j = 1&#8230;m) n = 3, m = 4**, необхідно її парні елементи переписати до масиву **b**, а непарні — до масиву **с**.



Алгоритм розв’язання цієї задачі наведено у **прикладі 1.6**



/* Р6_10.СРР — формирование массивов четных и нечетных элементов */
// использование имени массива как указателя на его начало
#include <iostream.h>
#include <conio.h>
const int n = 3, m = 4;
void main ()
{ int a[n][m], b[m*n], c[m*n], i, j, kc = 0, kn = 0;
// kc и kn — счетчики подсчета четных и нечетних элементов
//-------------------- ввод исходной матрицы а[n][m]
  cout << " Vvod massiva a[n][m] " << endl;
  for (і = 0; і < n; i++)
    for (j = 0; j < m; j++)
    cin >> *(*(a+i)+j);
//------------ формирование массивов b[ ] и c[ ]
for (i = 0; і < n; i++)
    for (j = 0; j < m; j++)
    if (*(*(a+i)+j)%2 == 0) *(b+kc++) = *(*(a+i)+j);
    else *(c+kn++) = *(*(a+i)+j);
//—-------- вывод массива b[] — четных элементов
  cout << endl << "massiv chetn. elementov — b[ ] " << endl;
  for (і = 0; і < kc; i++) 
  cout << *(b+i) << " ";
  cout << endl;
//----------------- вывод массива c[ ] — нечетных элементов
cout << endl << "massiv nechetn. elementov — c[ ]" << endl;
  for (і = 0; і < kn; i++)
  cout << *(c+i) << " ";
  cout << endl;
//------------------  вывод исходной матрицы a[n][m] в естественном  виде
 cout << endl << "ishodny massiv";
  for (і = 0; і < n; і++)
  { cout << endl;
    for (j = 0; j < m; j++)
    cout << *(*(a+i)+j) << " "; }
   getch();
}



Результати обчислень:


Vvod massiva a[n][m]
8 2 4 -1
6 1 0 -5
2 9 3 -1
massiv chetn. elementov — b[ ] 
8 2 4 6 0 2
massiv nechetn. elementov — c[ ] 
-1 1 -5 9 3 -1
ishodny massiv
8 2 4 -1
6 1 0 -5
2 9 3 -1.



У C++ можна описати змінну, що має **тип «покажчик на** **покажчик»**. Ознакою такого типу є повторення символа «*» при описі змінної, тобто **int **pmt;**.



Пам’ять для такої змінної не виділяється. Її треба привести до відповідного масиву. При описі покажчик на іпокажчик можна ініціювати:


int х = 20;
int *px1 = &amp;х;
int **рх2 = &amp;рх1;
int ***рхЗ = &amp;рх2;.
Доступ до змінної х здійснюється одним з трьох, способів:
*рх1;
 **px2;
 ***рхЗ;.



Для доступу до пам’яті через покажчики на покажчики використовуються як символи «*», так і індекси. Наприклад, іеквівалентими будуть такі посилання на змінну** х**:


*px1;               //рx1 [0];
**рх2;             //рх2 [0][0];
***рхЗ;           //рхЗ [0][0][0];.




## Сортування масивів


**Сортування масиву** — один з найбільш розповсюджених процесів обробки даних. Завдяки йому здійснюється розміщеня об&#8217;ектів у визначеному порядку, наприклад, чисел за зростанням або за спаданням їх значень, прізвищ у алфавітному порядку тощо. Існують різні методи сортування, серед них — обмінне сортування (метод «пухирця», «шейкер-сортування), сортування вибором, сортування вставками, швидке сортування, сортування Шелла, пірамідальне сортування, сортування обчисленням адреси, сортування порозрядним групуванням тощо. Ці методи відрізняються швидкістю отримання результату, складністю і універсальністю.



Розглянемо три методи сортування: обміном, вибором та вставками. Названі методи легко описуються у формі чітких алгоритмiв і передбачають нескладну програмну реалізацію, крім того вони цікаві тим, що моделюють природну поведінку людини, яка здійснює сортування вручну. З іншого боку, вказані методи не досить ефективні і використовуються у випадках, коли необхідно відсортувати масиви невеликого розміру.



**Обмінне сортування** проілюструємо простим сортуванням обмiном — **методом «пухирця»**, який здійснюється шляхом перестановки елементів за визначеним правилом. У загальному випадку алгоритм сортування за цим методом наведений у **прикладі 1.4**. Розглянемо його більш детально.



Нагадаємо головні складові методу «пухирця»:



* крок сортування містить перегляд елементів масиву з початку до кінця, при цьому розглядаються пари сусідніх елементів;
* елементи деякої пари міняються місцями у випадку, коли їх послідовність розташування не відповідає умові сортування (за зростанням або за спаданням).


**Приклад 6.11.** Упорядкувати за зростанням методом &#8220;пухирця&#8221; масив **xі (і = 0&#8230;n-1), n = 5**, що має значення:



**x0 = 25; x1 = 37; х2 = 0; х3 = 10; х4 = 2.**



Слід зауважити, що **жоден метод сортування не** **досягає результату за один перегляд масиву, для цього застосовується, як правило, цикл у циклі.**



В алгоритмі сортування за методом «пухирця» (**див. рис. 6.6.**) з цією метою використано зовнішній цикл (цикл кроків сортування) за параметром **k** та внутрішній цикл (цикл порівнянь перестановок) за параметром** і**. Оскільки кількість кроків сортування має бути **n-1**, то параметр **k **зовнішнього циклу змінюеться від 1 до **n-1** включно. На кожному кроці сортування у циклі за параметром** і **відбувається порівняння пар сусідніх елементів та їх перестановка у випадку, коли пара розташована не за зростанням. Параметр** і** відповідає номеру елемента масиву.



**Перший крок сортування** **(k = 1)** здійснюється так:



* послідовно порівнюються пари сусідніх елементів («25» «37») і, якщо перший елемент більше за другий, вони міняються місцями, тобто на друге місце, як пухирець, «спливае» більший з двох елементів (у даному випадку елементи залишаються на своїх місцях, елемент, що «спливає», виділенні шрифтом):
* потім другий елемент («37»), більший з двох, порівнюється з третім елементом («0»), і на третє місце «спливає» більший з трьох («37»):
* далі третій елемент («37») порівнюється з четвертим елементом («10»):
* перегляд продовжується до кінця масиву, і найбільший елемент «спливе» та займе останнє місце у масиві:


[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450820334_6_4.png)
**Другий крок сортування (k = 2)**, у результаті якого «спливає» вправо на передостаннє місце наступний найбільший елемент, дає таке розміщення елементів:



**Третій крок сортування (k = 3)** дозволяє розташувати наступний за величиною елемент третім справа:



І  далі останній **четвертий крок сортування (k = 4)** дає результат:



Сортування масивів за методом «пухирця» є найменш ефективним, середня кількість порівнянь дорівнює **(n2 &#8211; n)/2**. Незважаючи на це, метод залишається одним з найпопулярніших завдяки простоті реалізації.



Особливості застосування методу «пухирця»:



* алгоритми сортування, як за зростанням, так і за спаданням елементів, майже однакові, відрізняються вони тільки знаками порівняння, тобто, наприклад, замість **xі > х<sub>і+1</sub>** слід записати прямо протилежне — **x<sub>i</sub> < х<sub>і+1</sub>**
* присутність однакових елементів у масиві не додає проблем: у момент порівняння обидва елементи залишаються ні своїх місцях, а потім послідовно зміщуються по ряду та займають своє остаточне місце на сусідніх позиціях.Наведемо другий варіант програмної реалізації прикладу (**див. Р6_11_2.СРР**), в якому ім’я масиву використано як покажчик на його перший елемент:


/* Рr6_11 _2.СРР — сортировка одномерного массива по возрастанию методом «пузырька» */
//--------------- использование имени массива как указателя
#inchide <iostream.h>
#include <conio.h>
main( )
{ const int n = 5;
  int x[n], i, k;  int а;       /* а — рабочая переменная для перестановки местами двух элементов */
//----------- ввод исходного массива
  for (і = 0; і < n; i++)
   сіn >> *(x+i);
//----------- вывод на экран исходного массива
  cout << "\n massiv х[n] \n";
  for (i = 0; i < n; i++) 
  cout << *(x+i) << " "; 
//------------- сортировка no возрастанию
  for (k = 1; k < n; k++)       // цикл шагов сортировки
    for (і = 0; і < n-k; і++)    /* цикл сравненья элементов и их перестановки */
    if (*(x+i) > *(x+i+1))   
    { а = *(x+i);
     *(x+i) = *(x+i+1);
     *(x+i+1) = a; }
  cout << "\n Result sortirovki massiva " << endl;
  for (i=0; і < n; i++) 
  cout << *(x+i) << " ";
  getch();  
}



**Приклад 6.12.** Для матриці **matr(5,6)** знайти суми елементів кожного рядка та записати їх в одновимірний масив. Стриманий масив відсортувати за зростанням методом «пухирця».



// Р6 12.СРР - использование двумерных массивов 
/* занесение сумм элементов строк матрицы в массив и сортировка его по возрастанию методом "пузырька" */
#include <iostream.h>
#include <conio.h>
void main()
  { int matr[5][6], mas[5];      // mas[ ] — массив сумм  строк   
    int і, j, sum, stk;
//--------------------- ввод матрицы matr(5,6)
  cout << "Vvod matr[5][6] \n";
  for (і = 0; і < 5; і++)  
    for (j = 0; j < 6; j++)
    cin >> matr[i][j];
//--------------- формирование массива сумм элементов строк
  for (і = 0; sum = 0; і < 5; і++)  
  { // нахождение суммы элементов строки
    for (j = 0; j < 6; j++)
    sum += matr[i][j];
    mas[i] = sum }       //занесение суммы строки в массив
  cout << "\nMassiv summ el. strok" << endl; 
  for (і = 0; і < 5; i++) 
  cout << mas[i] << " ";
//------------------ сортировка массива сумм по возрастанию
  for (і = 1;   і < 5; і++)           // цикл шагов сортировки 
    for (j = 0; j < 5-і; j++)      // цикл сравнен. и перестан. элем.
    if (mas[j] > mas[j+1])
    { stk = mas[j];          // stk — для перестановки элементов 
      mas[j] = mas[j+1];     
      mas[j+1] = stk; }  
  cout << "\nOtsortirovanniy massiv \n";
  for (i = 0; і < 5; i++) 
  cout << mas[i] << " ";
  getch();            //задержка экрана вывода результата
}



Результати обчислень:


Vvod matr[5][6]
1 6 4 9 3 2
2 8 5 7 3 1
0 7 5 0 3 2
6 3 9 2 9 4
0 4 8 3 9 2
Massiv summ elementov strok 
25 26 21 33 31
Otsortirovanniy massiv
21 25 26 31 33


У програмі використані типові прийоми алгоритмізації &#8211; накопичення суми **sum** та формування робочого масиву **masj**, що запам&#8217;ятовує суми елементів кожного рядка матриці. Застосування цих прийомів докладно пояснене відповідно у **прикладі 1.2** та **прикладі 1.5.** Кількість елементів створеного масиву дорівнює кількості рядків матриці. Для сортування отриманого масиву за зростанням використано сортування методом «пухирця».


[Фрагмент лекції професора Девіда Малана із курса CS50 сортування “бульбашкою”](http://cpp.dp.ua/sortuvannya-bulbashkoyu/)

**Сортування за методом вибору** розглянемо на прикладі.



**Приклад 6.13.** Упорядкувати за зростанням методом вибору вихiдний масив, що має такі значення:



**x0 = 20; x1 = 1; х2 = 30; х3 = 2; х4 = 7, х5 = 5.**



Схему алгоритму та програму реалізації даної задачі наведено на **рис. 6.7.**



Процес сортування за зростанням здійснюється за кроками. Позначимо номер кроку сортування параметром** і**. На кожному кроці шукається найменший елемент, що міняється місцями з елементом, номер якого збігається з номером кроку **і**.



**Нульовий крок сортування** **(і = 0):**



у процесі розгляду елементів масиву, починаючи з першого, знаходять найменший елемент («1») і розташовують його на місце першого елемента, а перший («20») — на місце мінімального. У результаті найменший елемент масиву потрапляє
![null](/uploads/posts/2015-12/1450816903_6_3.png)
на нульову позицію, тобто на перше місце зліва (підкресленi елементи, що переставляються):


![null](http://cpp.dp.ua/uploads/posts/2015-12/1450820334_6_4.png)



  **Перший крок сортування (і = 1):**



наступний найменший елемент («2»)знаходять у частинi масиву, що починається з першої позиції. Він міняється місцями з другим елементом («20»), тобто другий за значенням елмент («2») розташується на першій позиції, а саме на другому місці зліва:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450820924_6_4_1.png)



**Другий крок сортування** **(і = 2):**
третій за значенням елемент («5») знайдемо у масиві, починаючи з другої позиції («З0»), та поміняємо його місцем з елементом  масиву, що розташувався на другій позиції:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821131_6_4_2.png)



Подальші кроки сортування дають такі перетворення: **третій крок сортування** **(і = 3):**


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821231_6_4_3.png)



**Четвертий крок сортування (і=4):**


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821238_6_4_4.png)



У результаті маємо відсортований за зростанням масив:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821258_6_4_5.png)



Загальна кількість дій алгоритму сортування за методом вибору дорівнює **(n2/4 + 3*n)** операціям.


[Фрагмент лекції професора Девіда Малана із курса CS50 сортування вибором](http://cpp.dp.ua/sortuvannya-vyborom/)

Сортування за методом вставки полягає в тому, що на кожному кроці відбувається вставка елемента у відсортований масив. Розглянемо цей метод на конкретному прикладі.



**Приклад 6.14.** Упорядкувати за зростанням (за спаданням) методом  вставки масив **аі (і = 0&#8230;n-1), n = 6**, що має такі значення:



**a0 = 4; а1 = 13; a2 = -3; а3 = 6; a4 = _8, a5 = 24.**



Схему алгоритму та програму реалізації цієї задачі наведено на **рис. 6.8.**
[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450906389_6_4_9.png)
**Сутність алгоритму сортування за методом вставки:**



* якщо **j (а<sub>0</sub>&#8230;а<sub>j</sub><sub>-1</sub>)** елементів масиву а відсортовані за зростанням, а елемент **a<sub>j</sub>** має довільне значення, потрібно порівнювати цей елемент по черзі з елементами **а<sub>j</sub><sub>-1</sub>, a<sub>j</sub><sub>-2</sub>,…**, доки для **a<sub>j</sub>** не знайдеться місце у відсортованому масиві. При цьому всі розглянуті елементи **a<sub>j</sub><sub>-1</sub>, a<sub>j-2</sub>** **,&#8230;**,що будуть за значенням більш ніж **a<sub>j</sub>** , мають переміститися на одну позицію вправо;
* у випадку, коли елемент-вставка aj виявиться більше за значенням , ніж **а<sub>j</sub><sub>-1</sub>**, елемент **a<sub>j</sub>** залишиться на своєму місці. Якщо **a**<sub>j</sub> буде менше всіх елементів **а<sub>0</sub>&#8230;а<sub>j</sub><sub>-1</sub>**, то всі елементи мають бути переміщені на одну позицію вправо, a **a<sub>j</sub>** займе місце **j = 0**. Що при переміщенні вправо не загубити значення елемента-вставки a<sub>j</sub>, потрібно завчасно зберегти його в робочій змінній (**rab**)


У програмі параметр і зовнішнього циклу відповідає за номер елемента-вставки, тому на першому кроці **(і = 1)** вважаємо що відсортований масив, до якого вставляється елемент **rab = aj** складається тільки з одного елемента, на наступному кроці **(і  = 2)** маємо відсортований масив з двох елементів, а вставляємо до нього елемент **а2** і так далі.



У внутрішньому циклі програми за параметром **j** відбувається порівняння елемента-вставки **rab** з елементами відсортованого масиву і переміщення цих елементів вправо, якщо за значенням вони більші, ніж **rab**. Безпосередньо вставка відбувається у зовнішньому циклі: **aj = rab.**



З розглянутих методів сортування цей метод — найефективніший, середня кількість операцій приблизно дорівнює **n2 / 4.** Наведемо ще один варіант (**див. Р6_14_2.СРР**) програмної реалізації сортування масиву за спаданням елементів з використанням методу вставки, в якій використано покажчики та застосовано цикл while для пошуку мiсця елемента вставки.



//Р6_14_2.СРР — сортировка методом вставки (по убыванию)
//---------------------- использование указателей
#include <iostream.h> 
#include <conio.h>
const int n=6; 
main ( )  
{ int a [n], i, j, rab;
  int *pmas; 
   pmas = a;      // pmas - &amp;a[0]; — указатель на начало массивам
 cout << "***** Введите 6 элементов массива" << endl;
 for (і = 0; і < n; i++)
   cin >> *pmas++; 
  pmas = a;      //pmas -= n; — указатель на начало массивa
  for (і = 1; і < n; і++)
   { rab= *(pmas + і); 
    j = і;      
    while (j > 0 &amp;&amp; rab > *(pmas + j-1))    
    { *(pmas + j) = *(pmas + j-1); 
       j-- }      
  *(pmas + j) = rab; }      
  cout << "Отсортированный массив по убыванию" << endl;      
  for (і = 0; і < n; i++) 
  cout << *(pmas + i) << " ";          
 getch();  
}



Результати виконання програми:



Введите 6 элементов массива 
4 12 -3 6 -8 24
Отсортированный массив по убыванию
24 12 6 4 -3 -8


[Фрагмент лекції професора Девіда Малана із курса CS50 сортування вибором](http://cpp.dp.ua/sortuvannya-vstavkoyu/)

**Приклад 6.15.** З двох впорядкованих за зростанням масивів **ai (i = 0...n-1) і bj (j = 0&#8230;m-1)** сформувати третій, також впорядкований, масив без додаткового сортування **(n = 8, m = 12).**



Алгоритм **злиття двох відсортованих масивів** (**див. рис. 6.9)** починається з порівняння перших елементів відповідних масивiв **а і b**. За лічильником і будемо вибирати елементи з масиву **а**, за лічильником  **j** — з масиву **b**, а за параметром  **k** — заносити елементи до масиву с. У масив с заноситься менший з елементів, що порівнюються, а далі в порівнянні бере участь наступний елемент того масиву, елемент якого вже записаний до с. Ця процедура повторюється, доки один з масивів не закiнчиться. Наприкінці слід тільки переписати до масиву с всі елементи іншого масиву, що залишилися.
[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450821386_6_4_8.png)



/* Р6_15.СРР — из двух массивов, отсортированных по возрастанию, сформировать третий */
#include <iostream.h>
#include <conio.h>
const int n=8, m=12;
void main()
{ int a[n], b[m], c[n+m];
  int i, j, k, 1;
//--------------- ввод двух отсортированных массивов
cout << "Vvedite 2 otsortirovanih massiva" << endl;
  for (i = 0; і < n; i++) 
  cin >> a[i];
  for (j = 0; j < m; j++)  
  cin >> b[j];
//------------------- слияние массивов a и b в массив с
 for (і = 0, j = 0, к = 0; і < n &amp;&amp; j < m; k++)  
  if (a[i] < b[j]) c[k] = a[i++];  
  else c[k] = b[j++];  
  if (i = = n)    
  for (l = k; l < n+m; l++) 
  c[l] = b[j++];  
  else 
  for (l = k; l < n+m; l++) 
  c[l] = a[i++];
//-------------- вывод полученного массива с
  cout << "Rezult — massiv c" << endl;
  for (і = 0; і < n+m; i++) 
  cout << c[i] << " ";
  getch();
}



Результати обчислень:


Vvedite 2 otsortirovanih massiva
1 4 11 17 33 54 60 62
1 5 9 14 15 19 20 23 44 48 72 80
Rezult — massiv c
1 2 4 5 9 11 14 15 17 19 20 23 33 44 48 54 60 62 72 80
Ефективний метод сортування великих масивів — **швидке cортування** — розглянутий у підрозділі **«Рекурсивні функції»**




## Динамічні масиви


В основній пам’яті дані можуть зберігатися двома способами



* пам’ять виділяється або в сегменті стека і залишається закріпленою до завершення виконання конкретної функції, або виділяється в сегменті даних на весь час виконання програми;
* пам’ять виділяється в міру потреби (динамічне виділення  пам’яті).


Слід зазначити, що всі приклади, розглянуті раніше, демонструють роботу з даними, які зберігаються першим способом.



**Динамічна пам’ять** — це вільна пам’ять, у якій під час виконання програми можна виділяти місце залежно від потреб користувача. **Доступ до виділених ділянок динамічної пам&#8217;яті, що називаються динамічними змінними, здійснюється** **тільки через покажчики.** Час існування динамічних змінних — від початку створення до кінця програми або до явного звільнення пам’яті. У мові C++ застосовують два способи роботи з динамічною пам’яттю. Перший з них дістався в спадщину від мови С і використовує сукупність функцій **malloc()**, другий — працює з операціями **new та delete**, які здійснюють динамічний розподіл і скасування з вищим пріоритетом, ніж інші функції.



Оператор **new** виділяє пам’ять і повертає її адресу. За допомогою оператора **delete** відбувається звільнення пам’яті, на яку вказує змінна-покажчик.



Загальна форма запису оператора **new**:



**змінна-покажчик = new тип змінної;.**



Оператор **delete** має вигляд:



**delete [ ] змінна-покажчик; **.



Динамічні масиви створюють за допомогою операції new, при цьому необхідно вказати їх тип і розмірність. Наприклад, Для одновимірного масиву дійсних чисел, що має 100 елементів, треба записати:



**int n = 100;**



** float *р = new float[n];** — змінна-покажчик на float виділяє у динамічній пам’яті ділянку для розміщення 100 елементів дійсного типу.



**Слід пам’ятати, що динамічні масиви при створенні не можна ні ініціювати, ні обнуляти.**



**Приклад 6.16.** З використанням динамічної пам’яті обробити вiдомість успішності групи студентів з дисципліни &#8220;Програмування&#8221; підрахувавши середній бал групи і кількість відмінників.



/* P6_16.CPP использование динамической памяти при обработке одномерного массива */
#include <iostream.h>
#include <conio.h>
#include <math.h>
main ( )
{ const int n = 14;                // количество студентов
  int *mas;                         // объявление указателя на массив
  int і, k = 0;                      // k — количество отличников
  float s = 0;                      // s — сумма оценок группы
  mas = new int [n];             //выделение динамической памяти
cout << " Ввод оценок " << endl;
  for (і = 0; і < n; і++)  
  сіn >> mas[i];
//---------------- подсчет суммы оценок и количества отличников
  for (і = 0; і < n; і++)
  { s = s + mas[i];
    if (mas[i] == 5) 
    k = k+1; }
  cout << endl; 
  cout.precision(3);
  cout << "Средний балл = " << s/n << endl;
  cout << "Количество отличников = " << k << endl;
  getch (); 
  delete[ ]mas;       // освобождение динамической памяти
}



Результати обчислень:


Ввод оценок
33345343245333
Средний балл = 3.43
Количество отличников = 2



У цій програмі змінна **s** служить для обчислення суми oцiнок групи, а змінна **k** — для підрахунку кількості відмінників. Перед обчисленням треба надати цим змінним початкове нульове значення (накопичення суми і кількості пояснено у **прикладах 1.1-1.2**).



При створенні динамічного багатовимірного масиву необхiдно в операції **new** вказати всі його розмірності (перший може бути змінною), наприклад:
**int n = 5;** // n — количество строк
**int **m = (int **) new int [n][5];.**



Розглянемо більш універсальний і безпечний спосіб видiлення динамічної пам’яті під двовимірний масив, коли обидвi йгого розмірностізадаються на етапі виконання програми. Наприклад, розподіл динамічної пам’яті для матриці, що має **n** рядкiв і **m** стовпців та елементи цілоготипу, можна здійснити так:



int n, m;
cout << &#8221; Введите количество строк и столбцов: &#8220;;
cin >> n >> m;
int **a = new int *[n]; — оголошення змінної тип «покажчи на покажчик на int» і виділення пам’яті для масиву покажчиків на рядки матриці;
for (int і = 0; і < n; і++)
a[і] = new int [m]; — кожному елементу масиву покажчиків на рядки присвоюється адреса початку ділянки пам’яті, виділеної для рядка матриці.



Наочно це представлено на **рис. 6.10.**
[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450895538_6_5.png)
Звільнення пам’яті з-під масиву будь-якої кількості вимірів виконується за допомогою операції **delete[].**



**Приклад 6.17.** З використанням динамічної пам’яті створити програму обчислення матриці С за формулою:



**С [n][q] = A[n][m] * B[m][q].**



Згідно з умовою, елемент матриці **C[n][q]** дорівнює сумі добутків елементів відповідного рядка матриці **A[n][m]** на елементи відповідного стовпця матриці



У запропонованій програмі для обчислення елементів добутку матриць організовано три вкладених цикли: цикл переборі рядків матриці **А**, цикл перебору стовпців матриці **В**, а також цикл накопичення суми для одержання елемента матриці **С**. Для виділення динамічної пам’яті під двовимірні масиви **A[n][m], B[m][q] і С [n][q]** скористаємося розглянутим вищі способом.



/* Р6_17.СРР — использование динамической памяти при работе с матрицами */
#include <iostream.h>
#include <math.h>
#include <conio.h>
main ( )
{ int і, j, k; 
  int n, m, q;
  cout << " Введите размерности матриц: \n";
  cout << " n = " ; 
  cin >> n;
  cout << " m = " ; 
  cin >> m;
  cout << " q = " ; 
  cin >> q;
//----------------- создание динамических массивов
/* выделение динамической памяти под массивы указателей и инициализация массивов указателей */
  int **С = new int *[n];
  for (int і = 0; і < n; і++)
  C[i] = new int [q];
  int **A = new int *[n];
  for (int і = 0; і < n; i++)
  A[i] = new int [m];
  int **B = new int *[m];
  for (int і = 0; і < m; i++)
  B[i] = new int [q];
//------------------------------ ввод матриц A[n][m] и B[m][q]
 cout<<"\n Ввод матрицы A[n][m] \n";
  for (і = 0; і < n; і++)
    for (j = 0; j < m; j++) 
    сіn >> *(А[i] + j);
    cout << "\n Ввод матрицы B[m][q] \n”;
  for (i = 0; і < m; i++) 
    for (j = 0; j < q; j++) 
    cin >> *(B[i] + j);
//----------------------- вычисление матрицы C[n][q] = A[n][m]*B[m][q]
  for (і = 0; і < n; i++)  // перебор строк матрицы A[n][m]
    for (k = 0; k<q; k++) //перебор столбцов матрицы B[m][q]
    { C[i][k] = 0; 
      for (j = 0; j < m; j++)
      C[i][k] += (A[i][j]* B[j][k]); // определение элемента C[i][k]
    }//-------------------- вывод на экран матрицы С[n][q]
  cout << "\n Матрица C[n][q] = A[n][m] * B[m][q] \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < q; j++)  
    cout << *(C[i] + j) << " ";
    cout << endl;}
  delete [ ]A; 
  delete [ ]B; 
  delete [ ]C;   // освобождение памяти
 getch (); 
}



Результати обчислень:


Введите размерности матриц:
n = 4 
m = З 
q = 5
Ввод матрицы A[n][m]
1 1 1
3 3 3
2 2 2
4 4 4
Ввод матрицы B[m][q]
8  8  8  8  8
7  7  7  7  7
5  5  5  5  5
Матрица C[n][q] = A[n][m] * B[m][q]
20 20 20 20 20
60 60 60 60 60
40 40 40 40 40
80 80 80 80 80


