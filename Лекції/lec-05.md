# МАСИВИ У С++

## Перелік лекцій


1.  [Склад мови С++](lec-01.md)
2.  [Типи даних та операції](lec-02.md)
3.  [Умовні оператори. Оператор вибору](lec-03.md)
4.  [Оператори циклів.](lec-04.md)
5.  [Масиви у С++](lec-05.md)
6.  [Дані символьного типу. Рядки](lec-06.md)
7.  [Функції. Бібліотеки функцій](lec-07.md)
8.  [Дані типу структура](lec-08.md)
9.  [Покажчики у С++](lec-09.md)
10. [Робота з динамічною пам'ятю](lec-10.md)
11. [Робота з файлами](lec-11.md)
12. [Обробка файлів за допомогою WinAPI32](lec-12.md)
13. [ООП. Класи та об'єкти. Члени класів](lec-13.md)
14. [ООП. Наслідування. Перевантаження операторів](lec-14.md)
15. [Паралельні обчислення за стандартом OpenMP](lec-15.md)
16. [Паралельні обчислення з бібліотекою MPI](lec-16.md)


## Використання масивів

На практиці часто виникає необхідність в обробці даних у вигляді довільного набору значень, тобто масивів. Масив являє собою кінцеву іменовану послідовність величин одного типу, які розрізняються за порядковим номером. Опис масивiв у програмі відрізняється від опису простої змінної наявністю після імені квадратних дужок «[ ]», в яких задається кількість елементів масиву (розмірність). Слід нагадати, що у мові C++ нумерація елементів масиву починається з 0.



Розглянемо одновимірні масиви, оголошення яких допускае одну з таких форм запису:



<тип> <ім’я> [n];
<тип> <ім’я> [n] = {значення};
<тип> <ім’я> [] = {значення};




При оголошенні одновимірного масиву, коли масив відразу iніціюється, можна не вказувати його розмір. Якщо ж ініціювання не здійснюється під час оголошення масиву, то кількість індексів слід задати обов’язково константним виразом. Наприклад:


```cpp
float m [6];
float m [6] = {3.4, 4.5, 5.6, 6.7, 8.9, 10.3};
float m [ ] = {3.45, 4.56, 5.67, 6.78};
```

Зрозуміло, що надалі кількість елементів змінити неможливо. Для того щоб обнулити елементи оголошеного масиву, достатньо ініціювати його перший елемент: int mas[0]={0};.



За замовчуванням, якщо в оголошеному масиві ініціюється тільки декілька перших елементів, то його інші елементи ініціюються нулями. Так, у випадку, коли float mas[10]= {2.2,34.56};, останні вісім елементів масиву одержать значення 0.



Проiлюструємо використання одновимірних масивів на конкретних прикладах.



Приклад 6.1. Обчислити функцію у = axi2 &#8211; sinxi аргументи якої xj &#8211; елементи одновимірного масиву, що мають значення:


х0 = -0,81; x1 = -0,58; х2 = -0,11; х3 = 0,2; х4 = 0,91; x5 = 1,83.



Схему алгоритму і програмну реалізацію цієї задачі наведе по на рис. 6.1. Алгоритм передбачає введення значень одновимірного масиву xi (і = 0...n-1), n = 6 та подальше застосування їx для обчислення функції.



У програмі спочатку описується масив дійсних значень : float х[n]. Введення елементів масиву здійснюється у циклі:


[medium]http://cpp.dp.ua/uploads/posts/2015-12/1450709122_6_1.png[/medium]



 Цей цикл містить операцію потокового введення cin >> x[i];, перед якою знаходиться пiдказка cout << &#8220;х[ &#8221; << і << &#8220;] =&#8221;; для вказiвки номера елемента x[i]. Особливість виконання операцii введення cin >> x[i]; полягає в такому: зустрiвши її у програмi, комп&#8217;ютер призупинить виконання програми, поки не буде введене значення елемента х[і] і натиснута клавіша Enter, пiсля чого робота програми буде продовжена. Зазначена операцiя введення повторюється n разiв для забезпечення введення всiх елементiв масиву.



Оскільки у С++ індексація елементiв масиву починается з нуля, то масив float x[6] (n = 6) iз шести елементiв включае идексованi елементи x[0], x[1], x[2], ..., x[5]. Програма (див.P6_1_1.CPP)  використовуе два цикли: один &#8211; для введення масиву, інший — для обчислення функції. Операцii введення елементів масиву та обчислення значень функції можна здiйсніити в одному циклi(див. P6_1_2.СРР).


```cpp
/* Р6_1_2.СРР — ввод элементов одномерного массива и вычисление функции осуществляется в одном цикле */
#include <iostream.h>
#include <math.h>
#include <conio.h>
main ( )
{ const int n = 7;
  float x[n], y, a(10.5);
  int i;
  for (i = 0;i< n;i++)
  {
    cin >> x[i];        //ввод елемента массива
    y = a * x[i] * x[i] - sin(x[i]);
//--------------------------------------- вывод результата
   cout << " x["<<i<<"] ="<<x[i]<<" y = " << y << endl;
 }
getch ();
}
```




Результати обчислень:
-0.81 -0.58 -0.11  0.2  0.91  1.83
x[0] = -0.81     у = 7.61334
х[1] = -0.58     у = 4.08022
х[2] = -0.11     у = 0.236828
x[3] = 0.2        у = 0.221331
x[4] = 0.91      у = 7.90555
х[5] = 1.83      у = 34.1969



У цьому випадку передбачено введення елементів масиву в рядок, і клавішу Enter слід натиснути в кiнцi процесу введення.



Приклад 6.2. Сформувати масив сk, який містить однакові елементи двох масивів аі (і = 0...n-1), n = 7 та bj (j = 0...m-1), m = 10. Масиви а і b не мають елементів, що повторюються.



Схему алгоритму і програмну реалізацію задачі наведено на рис. 6.2.


[medium]http://cpp.dp.ua/uploads/posts/2015-12/1450709815_6_1_1.png[/medium]



Цей приклад розв’язується з використанням вкладених циклів. Процес порівняння елементів відбувається немов у три руки. Одна рука за параметром і вибирає елемент з масиву аі, друга за параметром j вибирає елемент з масиву bj, а третя за параметром k розташовує вибраний елемент у масив сk.



Спочатку і = 0 (відбувається порівняння з а0), a j змінюється від 0 до m-1.



У циклі за параметром  j кожний елемент bj порівнюється з ai доти, поки не знайдеться ai = bj та не буде переглянутий весь масив bj. Якщо ai = bj, то bj заноситься до поточного елемента масиву ск.



Далі повторюються аналогічні порівняння для і (і = 1, 2, ... , n-1), тобто здійснюється порівняння елементів масиву bj з наступним елементом масиву ai.



Приклад 6.3. За один перегляд масиву cі(і = 0n-1), n = 15 визначити значення, а також положення максимального і мінімального його елементів та поміняти їх місцями.



Схему алгоритму розв’язання задачі та пояснення до неї наведено у прикладі 1.3 (див. рис. 1.3).


```cpp


/* Р6_3.СРР — определение максимального и минимального элементов массива c[n] и перестановка их местами */
#include <iostream.h>
#include <conio.h>  
const n=15;
void main ()
{   //описание массива с[n] и его инициализация
  float с[n] = {6.4, 1.5, -5.6, 3.7, 18.9, 10.3, -0.6, 44.5,-0.2, 8.9, 55.3, 6.9, 4.3, 7.7, 10.9};
  float max, min;       // максим, (max) и миним. (min) элементы
int imax, imin;        // индексы искомых элементов
//--------------------------вывод заданного массива с[n]
  cout << " * massiv c[n] * n= " << n << endl;
  for (int і = 0; і < n; і++) 
  cout << с[і] << " ";
/* определение максимального и минимального элементов массива и их индексов — imax, imin */ 
 max = min = c[0];
  imax = imin = 0;
  for (int i =1; i<n; i++)
  {
    if (c[i] >max)
 { max = c[i];
      imax = i; }
    else
    if (с[і] < min)
    { min = с[і];
      іmin = і; }
  }
//------------------------------ перестановка max и min элементов
  c[imin] = max;
  c[imax] = min;
//-------------------------------- вывод max, min, imax, imin
  cout << ”\n\t max=  " << max << " min= " << min << endl;
  cout << "\t imax= " << imax+1 << " imin= " << imin+1 << endl;
//-------------------------------- вывод преобразованного массива c[n]
  cout << "  Rezult massiv ” << endl;
  for (int і = 0; і < n; i++)
  cout << c[i] << " " ;
  getch ();       // задержка экрана
}

```

Результати обчислень:

```
* massiv c[n] * n= 15
6.4 1.5 -5.6 3.7 18.9 10.3 -0.6 44.5 -0.2 8.9 55.3 6.9 4.3 7.7 2.1 
max= 55.3          min= -5.6                                                          imax= 11           іmin= 3 
 Rezult massiv 
6.5 1.5 55.3 3.7 18.9 10.3 -0.6 44.5 -0.2 8.9 -5.6 6.9 4.3 7.7 2.1
```
      

Крім одновимірних масивів, тобто таких, де позиція елемента визначається за допомогою одного індексу, у практиці розв’язання задач часто застосовуються багатовимірні масиви. У них позиція елемента визначається записом декількох індексів. Найбільш розповсюджені двовимірні масиви або матриці. Матриці являють собою порядковий запис декількох одновимірних масивів. Місце розташування кожного елемента визначається за допомогою двох індексів — номера рядка і номера стовпця, тобто порядкового номера в рядку. Індекси двовимірних масивів записуються в квадратних дужках і нумерація індексів починається з нуля (0).



Наприклад, двовимірний масив цілих чисел int а[3][4], що має три рядки та чотири стовпці, представлений на рис. 6.3





а[0][0]
а[0][1]
а[0][2]
а[0][3]


а[1][0]
а[1][1]
а[1][2]
а[1][3]


а[2][0]
а[2][1]
а[2][2]
а[2][З]



Рис. 6.3. Вигляд двовимірного масиву (матриці) int а[3][4]



У пам’яті комп’ютера масив розташовується безперервно за рядками:



а [0][0], а [0][1], а [0][2], а [0][3], а [1][0], а [1][1], а [1][2], а [1][3], ... а [2][3].



Двовимірні (і багатовимірні) масиви оголошуються так:


int mas [2][5] ={ 1, 5, 3, 7, 4,10, 11, ІЗ, 14, 25 };
int mas [  ][5] ={ 1, 5, 3, 7, 4, 10, 11, 13, 14, 25 };
int mas [  ][5] ={ { 1, 5, 3, 7, 4 },{10, 11, 13, 14, 25} };




тобто масив задається або списком елементів у тому порядку, и якому вони розташовані у пам’яті, або подається як масив масивів, кожний з яких поміщається в свої фігурні дужки«{}». При оголошенні і одночасному ініціюванні багатовимірних масивів можна опускати кількість індексів тільки першого виміру. Якщо ініціювання не здійснюється під час оголошення масиву, то кількість індексів треба вказувати явно.



Для здійснення введення-виведення, а також для обробки елементів двовимірного масиву у програмі слід передбачати організацію двох циклів: один — для задання значень індексу рядків, другий — індексу стовпців.



Приклад 6.4. Кожний елемент матриці М(3,4) збільшити на задане число.

```cpp
// Р6_4. СРР — увеличение элементов матрицы на заданное число
#include <iostream.h>
#include <conio.h>
main()
{
  const int n = 3, m = 4;      /* n и m - количество строк и столбцов матрицы */
  float М [n][m], z = 10;      // z — заданное число
  int і, j;
//-------ввод элементов матрицы и увеличение их значений на z
  cout << " Vvod matrix " << endl;
  for (і = 0; і<n; i++)
    for (j = 0; j<m; j++)
 { cout << " M [" << і << "]" << "[" << j << "]=";
      cin >> M [i][j];
      M [i][j] += z;            // M [i][j]= M [i][j] + z;
   }
//-------вывод полученной матрицы в естественном виде
  cout << "\n\n* Rezult matrix: ";
 for (і = 0; і < n; і++)
  { cout << endl;   
    for (j = 0; j < m; j++)  
    cout << M [i][j] << " “;}
 getch();       // задержка экрана
}
```


Результати виконання програми:

```
* Vvod matrix 
М [0][0]=4.5 
М [0][1]=6.7 
М [0][2]=4.8 
М [0][3]=23.6 
М [1][0]=5.7 
М [1][1]=3.7 
М [1][2]=2.9 
М [1][3]=6.1 
М [2][0]=1.2 
М [2][1]=4.5 
М [2][2]=4.6 
М [2][3]=2.7
* Rezult matrix:
14.5   16.7   14.8   33.6
15.7   13.7   12.9   16.1
11.2   14.5   14.6   12.7
```


У програмі при описі матриці float M[n][m]; вказується діапазон змiни двох iндексiв, перший з яких призначений для iндексування рядків (і), другий — для індексування стовпців (j). Введення, обробка і виведення елементів матриці здійснюються за допомогою двох циклів, один з яких є вкладеним в іншій. Це дозволяє при кожному значенні змінної і перебирати всі значення змінної j. Розглянута програма може бути скорочена шляхом об’єднання всіх трьох блоків циклу в один, але в таксму випадку вона буде менш наочною.



Приклад 6.5. Елементи головної та побічної діагоналей матриці С(4,4) поміняти місцями. Визначити максимальний елемент перетвореної матриці, а також номери рядка та стовпця, на перетині яких він знаходиться.



Схему алгоритму до прикладу наведено на рис. 6.4.


[medium]http://cpp.dp.ua/uploads/posts/2015-12/1450812241_6_1_2.png[/medium]



Програму розроблено з використанням алгоритму знаходження максимального елемента масиву та його індексів (див. приклад 1.3).


```cpp
//P65.CPP — перестановка элементов главной и побочной диагоналей
//--------- определение максимального элемента матрицы и его индексов
#include <iostream.h>
#include <conio.h>
void main ()
{ const int n = 4;
  int і, j, imax, jmax;
 float max, C[ ][n] = {  {3.6, 8.9, 1.9, 5.8},
                {8.8, 4.1, 1.2, 6.3},
                {2.5, 6.4, 0.1, 5.5},
                {8.8, 4.1, 1.2, 6.3} };   //инициализация С[n][n]
//-------------------------------- вывод исходной матрицы в естественном виде
 cout << " * massiv C[n][n] *"; 
  for (i = 0; i < n; i++)
  { cout << endl;
    for (j = 0; j < n; j++)
    cout << C[i][j] << " "; }
//--------------------------- перестановка элементов главной и побочной диагоналей
  float rab;          // вспомогательная переменная для перестановки
  for (i = 0; i < n; i++)     // for (i = 0, j = n-1; i < n; i++, j--)
 { j = n-1-i;                    // { rab = C[i][i];
  rab = C[i][i];                //C[i][i]=C[i][j];
C[i]|i] =C[i][j];             //C[i][j] = rab; }
C[i][j] = rab; }
//----------------------------- вывод преобразованной матрицы
 cout<<"\n\n * REZULT massiv * ";
  for (i = 0; i < n; i++)
  { cout << endl; 
    for (j = 0; j < n; j++) 
    cout << C[i]|j] << "   "; }
// определение max элемента матрицы его индексов — imax, jmax 
  max = С[0][0];
  imax = jmax = 0;  
  for (i = 0; i < n; i++)   
    for (j = 0; j < n; j++)
      if (С[i][j] > max)
      { max = C[i][j];   
        imax = i; jmax = j; }
  cout << "\n\n max= " << max << "  index stroki = " << imax+1 << “ index stolbca = “<< jmax+1;
  getch();
}
```


Результати обчислень:


* massiv C[n][n] *
3.6  8.9  1.9  5.8
8.8  4.1  1.2  6.3
2.5  6.4  0.1  5.5
8.8  4.1  1.2  6.3
* REZULT massiv *
5.8  8.9  1.9  3.6
8.8  1.2  4.1  6.3
2.5  0.1  6.4  5.5
6.3  4.1  1.2  8.8
max = 8.9 index stroki = 1 index stolbca = 2 .


## Сортування масивів


Сортування масиву — один з найбільш розповсюджених процесів обробки даних. Завдяки йому здійснюється розміщеня об'ектів у визначеному порядку, наприклад, чисел за зростанням або за спаданням їх значень, прізвищ у алфавітному порядку тощо. Існують різні методи сортування, серед них — обмінне сортування (метод «пухирця», «шейкер-сортування), сортування вибором, сортування вставками, швидке сортування, сортування Шелла, пірамідальне сортування, сортування обчисленням адреси, сортування порозрядним групуванням тощо. Ці методи відрізняються швидкістю отримання результату, складністю і універсальністю.



Розглянемо три методи сортування: обміном, вибором та вставками. Названі методи легко описуються у формі чітких алгоритмiв і передбачають нескладну програмну реалізацію, крім того вони цікаві тим, що моделюють природну поведінку людини, яка здійснює сортування вручну. З іншого боку, вказані методи не досить ефективні і використовуються у випадках, коли необхідно відсортувати масиви невеликого розміру.



Обмінне сортування проілюструємо простим сортуванням обмiном — методом «пухирця», який здійснюється шляхом перестановки елементів за визначеним правилом. У загальному випадку алгоритм сортування за цим методом наведений у прикладі 1.4. Розглянемо його більш детально.



Нагадаємо головні складові методу «пухирця»:



* крок сортування містить перегляд елементів масиву з початку до кінця, при цьому розглядаються пари сусідніх елементів;
* елементи деякої пари міняються місцями у випадку, коли їх послідовність розташування не відповідає умові сортування (за зростанням або за спаданням).


Приклад 6.11. Упорядкувати за зростанням методом &#8220;пухирця&#8221; масив xі (і = 0...n-1), n = 5, що має значення:



x0 = 25; x1 = 37; х2 = 0; х3 = 10; х4 = 2.



Слід зауважити, що жоден метод сортування не досягає результату за один перегляд масиву, для цього застосовується, як правило, цикл у циклі.



В алгоритмі сортування за методом «пухирця» (див. рис. 6.6.) з цією метою використано зовнішній цикл (цикл кроків сортування) за параметром k та внутрішній цикл (цикл порівнянь перестановок) за параметром і. Оскільки кількість кроків сортування має бути n-1, то параметр k зовнішнього циклу змінюеться від 1 до n-1 включно. На кожному кроці сортування у циклі за параметром і відбувається порівняння пар сусідніх елементів та їх перестановка у випадку, коли пара розташована не за зростанням. Параметр і відповідає номеру елемента масиву.



Перший крок сортування (k = 1) здійснюється так:



* послідовно порівнюються пари сусідніх елементів («25» «37») і, якщо перший елемент більше за другий, вони міняються місцями, тобто на друге місце, як пухирець, «спливае» більший з двох елементів (у даному випадку елементи залишаються на своїх місцях, елемент, що «спливає», виділенні шрифтом):
* потім другий елемент («37»), більший з двох, порівнюється з третім елементом («0»), і на третє місце «спливає» більший з трьох («37»):
* далі третій елемент («37») порівнюється з четвертим елементом («10»):
* перегляд продовжується до кінця масиву, і найбільший елемент «спливе» та займе останнє місце у масиві:


[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450820334_6_4.png)
Другий крок сортування (k = 2), у результаті якого «спливає» вправо на передостаннє місце наступний найбільший елемент, дає таке розміщення елементів:



Третій крок сортування (k = 3) дозволяє розташувати наступний за величиною елемент третім справа:



І  далі останній четвертий крок сортування (k = 4) дає результат:



Сортування масивів за методом «пухирця» є найменш ефективним, середня кількість порівнянь дорівнює (n2 - n)/2. Незважаючи на це, метод залишається одним з найпопулярніших завдяки простоті реалізації.



Особливості застосування методу «пухирця»:



* алгоритми сортування, як за зростанням, так і за спаданням елементів, майже однакові, відрізняються вони тільки знаками порівняння, тобто, наприклад, замість xі > х<sub>і+1</sub> слід записати прямо протилежне — x<sub>i</sub> < х<sub>і+1</sub>
* присутність однакових елементів у масиві не додає проблем: у момент порівняння обидва елементи залишаються ні своїх місцях, а потім послідовно зміщуються по ряду та займають своє остаточне місце на сусідніх позиціях.Наведемо другий варіант програмної реалізації прикладу (див. Р6_11_2.СРР), в якому ім’я масиву використано як покажчик на його перший елемент:

```cpp
/* Рr6_11 _2.СРР — сортировка одномерного массива по возрастанию методом «пузырька» */
//--------------- использование имени массива как указателя
#inchide <iostream.h>
#include <conio.h>
main( )
{ const int n = 5;
  int x[n], i, k;  int а;       /* а — рабочая переменная для перестановки местами двух элементов */
//----------- ввод исходного массива
  for (і = 0; і < n; i++)
   сіn >> *(x+i);
//----------- вывод на экран исходного массива
  cout << "\n massiv х[n] \n";
  for (i = 0; i < n; i++) 
  cout << *(x+i) << " "; 
//------------- сортировка no возрастанию
  for (k = 1; k < n; k++)       // цикл шагов сортировки
    for (і = 0; і < n-k; і++)    /* цикл сравненья элементов и их перестановки */
    if (*(x+i) > *(x+i+1))   
    { а = *(x+i);
     *(x+i) = *(x+i+1);
     *(x+i+1) = a; }
  cout << "\n Result sortirovki massiva " << endl;
  for (i=0; і < n; i++) 
  cout << *(x+i) << " ";
  getch();  
}
```




Приклад 6.12. Для матриці matr(5,6) знайти суми елементів кожного рядка та записати їх в одновимірний масив. Стриманий масив відсортувати за зростанням методом «пухирця».


```cpp
// Р6 12.СРР - использование двумерных массивов 
/* занесение сумм элементов строк матрицы в массив и сортировка его по возрастанию методом "пузырька" */
#include <iostream.h>
#include <conio.h>
void main()
  { int matr[5][6], mas[5];      // mas[ ] — массив сумм  строк   
    int і, j, sum, stk;
//--------------------- ввод матрицы matr(5,6)
  cout << "Vvod matr[5][6] \n";
  for (і = 0; і < 5; і++)  
    for (j = 0; j < 6; j++)
    cin >> matr[i][j];
//--------------- формирование массива сумм элементов строк
  for (і = 0; sum = 0; і < 5; і++)  
  { // нахождение суммы элементов строки
    for (j = 0; j < 6; j++)
    sum += matr[i][j];
    mas[i] = sum }       //занесение суммы строки в массив
  cout << "\nMassiv summ el. strok" << endl; 
  for (і = 0; і < 5; i++) 
  cout << mas[i] << " ";
//------------------ сортировка массива сумм по возрастанию
  for (і = 1;   і < 5; і++)           // цикл шагов сортировки 
    for (j = 0; j < 5-і; j++)      // цикл сравнен. и перестан. элем.
    if (mas[j] > mas[j+1])
    { stk = mas[j];          // stk — для перестановки элементов 
      mas[j] = mas[j+1];     
      mas[j+1] = stk; }  
  cout << "\nOtsortirovanniy massiv \n";
  for (i = 0; і < 5; i++) 
  cout << mas[i] << " ";
  getch();            //задержка экрана вывода результата
}
```




Результати обчислень:

```
Vvod matr[5][6]
1 6 4 9 3 2
2 8 5 7 3 1
0 7 5 0 3 2
6 3 9 2 9 4
0 4 8 3 9 2
Massiv summ elementov strok 
25 26 21 33 31
Otsortirovanniy massiv
21 25 26 31 33
```



У програмі використані типові прийоми алгоритмізації - накопичення суми sum та формування робочого масиву masj, що запам'ятовує суми елементів кожного рядка матриці. Застосування цих прийомів докладно пояснене відповідно у прикладі 1.2 та прикладі 1.5. Кількість елементів створеного масиву дорівнює кількості рядків матриці. Для сортування отриманого масиву за зростанням використано сортування методом «пухирця».


[Фрагмент лекції професора Девіда Малана із курса CS50 сортування “бульбашкою”](http://cpp.dp.ua/sortuvannya-bulbashkoyu/)

Сортування за методом вибору розглянемо на прикладі.



Приклад 6.13. Упорядкувати за зростанням методом вибору вихiдний масив, що має такі значення:



x0 = 20; x1 = 1; х2 = 30; х3 = 2; х4 = 7, х5 = 5.



Схему алгоритму та програму реалізації даної задачі наведено на рис. 6.7.



Процес сортування за зростанням здійснюється за кроками. Позначимо номер кроку сортування параметром і. На кожному кроці шукається найменший елемент, що міняється місцями з елементом, номер якого збігається з номером кроку і.



Нульовий крок сортування (і = 0):



у процесі розгляду елементів масиву, починаючи з першого, знаходять найменший елемент («1») і розташовують його на місце першого елемента, а перший («20») — на місце мінімального. У результаті найменший елемент масиву потрапляє
![null](/uploads/posts/2015-12/1450816903_6_3.png)
на нульову позицію, тобто на перше місце зліва (підкресленi елементи, що переставляються):


![null](http://cpp.dp.ua/uploads/posts/2015-12/1450820334_6_4.png)



  Перший крок сортування (і = 1):



наступний найменший елемент («2»)знаходять у частинi масиву, що починається з першої позиції. Він міняється місцями з другим елементом («20»), тобто другий за значенням елмент («2») розташується на першій позиції, а саме на другому місці зліва:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450820924_6_4_1.png)



Другий крок сортування (і = 2):
третій за значенням елемент («5») знайдемо у масиві, починаючи з другої позиції («З0»), та поміняємо його місцем з елементом  масиву, що розташувався на другій позиції:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821131_6_4_2.png)



Подальші кроки сортування дають такі перетворення: третій крок сортування (і = 3):


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821231_6_4_3.png)



Четвертий крок сортування (і=4):


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821238_6_4_4.png)



У результаті маємо відсортований за зростанням масив:


![](http://cpp.dp.ua/uploads/posts/2015-12/1450821258_6_4_5.png)



Загальна кількість дій алгоритму сортування за методом вибору дорівнює `(n2/4 + 3*n)` операціям.


[Фрагмент лекції професора Девіда Малана із курса CS50 сортування вибором](http://cpp.dp.ua/sortuvannya-vyborom/)

Сортування за методом вставки полягає в тому, що на кожному кроці відбувається вставка елемента у відсортований масив. Розглянемо цей метод на конкретному прикладі.



Приклад 6.14. Упорядкувати за зростанням (за спаданням) методом  вставки масив аі (і = 0...n-1), n = 6, що має такі значення:



a0 = 4; а1 = 13; a2 = -3; а3 = 6; a4 = 8, a5 = 24.



Схему алгоритму та програму реалізації цієї задачі наведено на рис. 6.8.
[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450906389_6_4_9.png)
Сутність алгоритму сортування за методом вставки:



* якщо j (а<sub>0</sub>...а<sub>j</sub><sub>-1</sub>) елементів масиву а відсортовані за зростанням, а елемент a<sub>j</sub> має довільне значення, потрібно порівнювати цей елемент по черзі з елементами а<sub>j</sub><sub>-1</sub>, a<sub>j</sub><sub>-2</sub>,…, доки для a<sub>j</sub> не знайдеться місце у відсортованому масиві. При цьому всі розглянуті елементи a<sub>j</sub><sub>-1</sub>, a<sub>j-2</sub> ,...,що будуть за значенням більш ніж a<sub>j</sub> , мають переміститися на одну позицію вправо;
* у випадку, коли елемент-вставка aj виявиться більше за значенням , ніж а<sub>j</sub><sub>-1</sub>, елемент a<sub>j</sub> залишиться на своєму місці. Якщо a<sub>j</sub> буде менше всіх елементів а<sub>0</sub>...а<sub>j</sub><sub>-1</sub>, то всі елементи мають бути переміщені на одну позицію вправо, a a<sub>j</sub> займе місце j = 0. Що при переміщенні вправо не загубити значення елемента-вставки a<sub>j</sub>, потрібно завчасно зберегти його в робочій змінній (rab)


У програмі параметр і зовнішнього циклу відповідає за номер елемента-вставки, тому на першому кроці `(і = 1)` вважаємо що відсортований масив, до якого вставляється елемент `rab = aj` складається тільки з одного елемента, на наступному кроці `(і = 2)` маємо відсортований масив з двох елементів, а вставляємо до нього елемент а2 і так далі.



У внутрішньому циклі програми за параметром j відбувається порівняння елемента-вставки rab з елементами відсортованого масиву і переміщення цих елементів вправо, якщо за значенням вони більші, ніж rab. Безпосередньо вставка відбувається у зовнішньому циклі: aj = rab.



З розглянутих методів сортування цей метод — найефективніший, середня кількість операцій приблизно дорівнює n2 / 4. Наведемо ще один варіант (див. Р6_14_2.СРР) програмної реалізації сортування масиву за спаданням елементів з використанням методу вставки, в якій використано покажчики та застосовано цикл while для пошуку мiсця елемента вставки.


```cpp
//Р6_14_2.СРР — сортировка методом вставки (по убыванию)
//---------------------- использование указателей
#include <iostream.h> 
#include <conio.h>
const int n=6; 
main ( )  
{ int a[n], i, j, rab;
  int *pmas; 
   pmas = a;      // pmas - &a[0]; — указатель на начало массивам
 cout << "* Введите 6 элементов массива" << endl;
 for (і = 0; і < n; i++)
   cin >> *pmas++; 
  pmas = a;      //pmas -= n; — указатель на начало массивa
  for (і = 1; і < n; і++)
   { rab= *(pmas + і); 
    j = і;      
    while (j > 0 && rab > *(pmas + j-1))    
    { *(pmas + j) = *(pmas + j-1); 
       j-- }      
  *(pmas + j) = rab; }      
  cout << "Отсортированный массив по убыванию" << endl;      
  for (і = 0; і < n; i++) 
  cout << *(pmas + i) << " ";          
 getch();  
}
```




Результати виконання програми:


```
Введите 6 элементов массива 
4 12 -3 6 -8 24
Отсортированный массив по убыванию
24 12 6 4 -3 -8
```



[Фрагмент лекції професора Девіда Малана із курса CS50 сортування вибором](http://cpp.dp.ua/sortuvannya-vstavkoyu/)

Приклад 6.15. З двох впорядкованих за зростанням масивів ai (i = 0...n-1) і bj (j = 0...m-1) сформувати третій, також впорядкований, масив без додаткового сортування (n = 8, m = 12).



Алгоритм злиття двох відсортованих масивів (див. рис. 6.9) починається з порівняння перших елементів відповідних масивiв а і b. За лічильником і будемо вибирати елементи з масиву а, за лічильником  j — з масиву b, а за параметром  k — заносити елементи до масиву с. У масив с заноситься менший з елементів, що порівнюються, а далі в порівнянні бере участь наступний елемент того масиву, елемент якого вже записаний до с. Ця процедура повторюється, доки один з масивів не закiнчиться. Наприкінці слід тільки переписати до масиву с всі елементи іншого масиву, що залишилися.
[|IMG|](http://cpp.dp.ua/uploads/posts/2015-12/1450821386_6_4_8.png)


```cpp
/* Р6_15.СРР — из двух массивов, отсортированных по возрастанию, сформировать третий */
#include <iostream.h>
#include <conio.h>
const int n=8, m=12;
void main()
{ int a[n], b[m], c[n+m];
  int i, j, k, 1;
//--------------- ввод двух отсортированных массивов
cout << "Vvedite 2 otsortirovanih massiva" << endl;
  for (i = 0; і < n; i++) 
  cin >> a[i];
  for (j = 0; j < m; j++)  
  cin >> b[j];
//------------------- слияние массивов a и b в массив с
 for (і = 0, j = 0, к = 0; і < n && j < m; k++)  
  if (a[i] < b[j]) c[k] = a[i++];  
  else c[k] = b[j++];  
  if (i == n)    
  for (l = k; l < n+m; l++) 
  c[l] = b[j++];  
  else 
  for (l = k; l < n+m; l++) 
  c[l] = a[i++];
//-------------- вывод полученного массива с
  cout << "Rezult — massiv c" << endl;
  for (і = 0; і < n+m; i++) 
  cout << c[i] << " ";
  getch();
}

```



Результати обчислень:

```
Vvedite 2 otsortirovanih massiva
1 4 11 17 33 54 60 62
1 5 9 14 15 19 20 23 44 48 72 80
Rezult — massiv c
1 2 4 5 9 11 14 15 17 19 20 23 33 44 48 54 60 62 72 80
```
Ефективний метод сортування великих масивів — швидке cортування — розглянутий у підрозділі «Рекурсивні функції»







## Контрольні запитання


 


1. Що таке масив та які існують різновиди масивів?
1. Як здійснюється звернення до елементів масивів?
1. Як у С++ реалізується введення-виведення елементів масиву?
1. Охарактеризуйте поняття «покажчик» та наведіть приклади.
1. Які операції дозволені для змінних-покажчиків?
1. Що таке масиви покажчиків та які особливості їх використання?
1. Охарактеризуйте алгоритм сортування за методом «пухирця».
1. Охарактеризуйте алгоритми сортування за методом вибору.
1. Охарактеризуйте поняття «динамічна пам’ять» та и можливості.
1. Як обробляються масиви з використанням динамічної пам’яті?





