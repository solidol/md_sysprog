# Робота з файлами

## Перелік лекцій


1.  [Склад мови С++](lec-01.md)
2.  [Типи даних та операції](lec-02.md)
3.  [Умовні оператори. Оператор вибору](lec-03.md)
4.  [Оператори циклів.](lec-04.md)
5.  [Масиви у С++](lec-05.md)
6.  [Дані символьного типу. Рядки](lec-06.md)
7.  [Функції. Бібліотеки функцій](lec-07.md)
8.  [Дані типу структура](lec-08.md)
9.  [Покажчики у С++](lec-09.md)
10. [Робота з динамічною пам'ятю](lec-10.md)
11. [Робота з файлами](lec-11.md)
12. [Обробка файлів за допомогою WinAPI32](lec-12.md)
13. [ООП. Класи та об'єкти. Члени класів](lec-13.md)
14. [ООП. Наслідування. Перевантаження операторів](lec-14.md)
15. [Паралельні обчислення за стандартом OpenMP](lec-15.md)
16. [Паралельні обчислення з бібліотекою MPI](lec-16.md)

## Загальні поняття

Особливістю мов С та С++ є відсутність заздалегідь спланованих структур файлів. 
> Усі файли розглядаються як неструктурована послідовність байтів. 
При такому підході до організації файлів вдалося поширити поняття файлу і різні пристрої. Конкретному пристрою відповідає так званий "спеціальний файл", а ті самі функції бібліотеки мови Сі використовуються, як для обміну даними з файлами, так і для обміну з пристроями.
На рівні потокового введення-виведення обмін даними проводиться побайтно. Таке введення-виведення можливе як для власне пристроїв побайтового обміну (принтер, дисплей), так і для файлів на диску, хоча пристрої зовнішньої пам'яті, строго кажучи, є пристроями побічного обміну, тобто. За одне звернення до пристрою проводиться зчитування або запис фіксованої порції даних Найчастіше мінімальною порцією даних, що бере участь в обміні із зовнішньою пам'яттю, є блоки 512 байт або 1024 байта. При введенні з диска (при читанні з файлу) дані розміщуються в буфер операційної системи, а потім побайтно або певними порціями передаються програмі користувача. При виведенні даних у файл вони накопичуються в буфері, а при переповненні буфера записуються як єдиного блоку на диск за одне звернення до останнього.
> Таким чином, потік - це файл разом із засобами буферизації.
При роботі з потоком можна робити такі дії:
* відкривати та закривати потоки (пов'язувати покажчики на потоки з конкретними файлами);
* вводити та виводити: символ, рядок, форматовані дані, порцію даних довільної довжини
* аналізувати помилки потокового введення-виводу та умову досягнення кінця потоку (кінця файлу);
* керувати буферизацією потоку та розміром буфера;
* отримувати та встановлювати покажчик (індикатор) поточної позиції у потоці.

## Засоби бібліотеки STDIO

Для того щоб можна було використовувати функції бібліотеки вводу-виводу мови С, в програму необхідно включити заголовний файл stdio.h, який містить прототипи функцій введення-виводу, а також визначення констант, типів і структур, необхідних для обміну потоком.
Перш ніж почати працювати з потоком, його необхідно ініціалізувати, тобто. відкрити. При цьому потік зв'язується у виконуваній програмі зі структурою визначеного типу FILE. Визначення структурного типу FILE знаходиться в заголовному файлі stdio.h. У структурі FILE містяться компоненти, за допомогою яких ведеться робота з потоком, зокрема: покажчик на буфер, покажчик (індикатор) поточної позиції в потоці та інша інформація.
При відкритті потоку в програму повертається покажчик потік, що є покажчиком на об'єкт структурного типу FILE. Цей покажчик ідентифікує потік у всіх наступних операціях.
Покажчик на потік, наприклад fp, повинен бути оголошений в програмі. Він набуває значення в результаті виконання функції відкриття потоку:
```cpp
FILE *fp;
fp = fopen (filename, mode);
```
Параметри `filename` і `mode` є вказівниками на масиви символів, містять відповідно ім'я файлу, що з потоком, і рядок режимів відкриття. Однак ці параметри можуть задаватися безпосередньо у вигляді рядків при виклику функції відкриття файлу:
Стандартно файл, пов'язаний із потоком, можна відкрити й одному з наступних шести режимів:
* "w" - новий текстовий (див. нижче) файл відкривається для запису. Якщо файл вже існував, попередній вміст стирається, файл створюється заново;
* "r" - існуючий текстовий файл відкривається лише для читання;
* "а" - текстовий файл відкривається (або створюється, якщо файлу немає) для додавання до нього нової порції інформації (додавання в кінець файлу). На відміну від режиму "w", режим "а" дозволяє відкривати вже існуючий файл, не знищуючи його попередньої версії, і писати в продовження файлу;
* "w+" - новий текстовий файл відкривається для запису та подальших багаторазових виправлень. Якщо файл вже існує, попередній вміст стирається. Наступні після відкриття файлу запис і читання з нього допустимі будь-де файлу, зокрема запис дозволено й у кінець файлу, тобто. файл може збільшуватися ("рости");
* "r+" - існуючий текстовий файл відкривається як читання, так записи будь-де файлу; проте у цьому режимі неможлива запис у кінець файлу, тобто. неприпустимо збільшення розмірів файлу;
* "а+" - текстовий файл відкривається чи створюється (якщо файлу немає) і стає доступним змін, тобто. для запису та для читання в будь-якому місці; при цьому на відміну від режиму "w+" можна відкрити існуючий файл і не знищувати його вмісту; на відміну режиму "r+" як "а+" можна вести запис наприкінці файла, тобто. збільшувати його розміри.
Після того як файл відкритий, з ним можна працювати, записуючи в нього інформацію або зчитуючи її (залежно від режиму).
Відкриті файли на диску після закінчення роботи з ними рекомендується закрити явно. Для цього використовується бібліотечна функція
```cpp
int fclose (fp);
```
Відкритий файл можна відкрити повторно (наприклад, для зміни режиму роботи з ним) тільки після того, як файл закритий за допомогою функції fclose().

## Засоби бібліотеки FSTREAM

Хедер fstream надає функціонал для зчитування даних із файлу та для запису у файл. Загалом він дуже схожий на хедер iostream, який працює з консоллю, оскільки консоль це теж файл.
Найбільш часті операції наступне:

* Оператори перенаправлення введення/виводу - << і >>
* Методи запису та читання рядків getline() та get() c put()
* Потоковий запис та читання методами write() та read()
* Методи відкриття\створення та закриття файлів open() та close()
* Методи перевірки чи відкрити файл is_open() і досягнуто кінець файлу eof()
* Налаштування форматованого виводу для >> за допомогою width() та precision()
* Операції позиціонування tellg(), tellp() та seekg(), seekp()

### Клас ifstream

Надає можливості читання файлів. Відкрити файл можна двома способами: викликавши метод open() або вказавши шлях до нього у конструкторі. Вам необхідно підготувати текстовий файл, перш ніж почати набирати код. На диску d створіть папку з ім'ям "1" і створіть файл з розширенням txt – "файл.txt".
```cpp
//Відкриття файлу методом open() C++
#include <iostream>
#include <fstream> // підключаємо бібліотеку
using namespace std;

int main()
{
ifstream file; // створюємо об'єкт класу ifstream
file.open("d:\\1\\файл.txt"); // відкриваємо файл
}
```

```cpp
int main()
{
ifstream file ("d:\1\файл.txt"); // відкриваємо файл у конструкторі
}
```
Так ми просимо відкрити файл txt з ім'ям файл.txt, який лежить у папці під назвою 1, а папка знаходиться на диску d.

Використання методу open() зручно, якщо програміст не хоче відразу прив'язуватися до файлу. Раптом потрібна якість класу або глобальну змінну, а відкривати файл вже потім. Якщо потрібно відкрити файл всередині певної функції, попрацювати з ним і закрити, можна прописати шлях до файлу у конструкторі. Загалом, залежить від ситуації.

Відкривши файл, бажано прописати перевірку: чи він відкрився? Так як є ряд причин, через які файл може не відкритися, а ми цього не побачимо. Наприклад, файлу з вказаним ім'ям немає в прописаній папці або шлях вказаний неправильно. Можна піти двома шляхами: перевірити змінну файлу в логічному виразі (застосувавши оператор “!”, наприклад) або використовувати метод is_open() :

Перевірка відкриття файлу умовою if
C++
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
setlocale(LC_ALL, "rus");

ifstream file ("d:\1\файл.txt");

if (! file)
{
cout << "Файл не відкритий\n";
return -1;
}
else
{
cout << "Всі ОК! Файл відкритий!\n\n";
return 1;
}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21

#include <iostream>
#include <fstream>
using namespace std;
 
int main()
{
 setlocale(LC_ALL, "rus");
 
 ifstream file ("d:\1\файл.txt");
 
 if (! file)
 {
 cout << "Файл не відкритий\n";
 return -1;
 }
 else
 {
 cout << "Всі ОК! Файл відкритий!\n\n";
 return 1;
 }
}

Так все відпрацює нормально та файл відкриється:

бібліотека fstream, робота з файлами в с++, програмування для початківцівТепер спробуйте вписати назву папки не 1, а 2 ifstream file ("d:\<span style="color: #ff0000;"><strong>2</strong >\\файл.txt"); і знову запустіть програму. Так як папки з вказаним ім'ям ми не створювали, то і файл, природно, не може бути відкритий:

бібліотека fstream, робота з файлами в с++, програмування для початківців

Другий варіант перевірки з використанням методу is_open() :
Перевірка методом is_open()
C++
#include <iostream>
#include <fstream>
using namespace std;

int main()
{
setlocale(LC_ALL, "rus");

ifstream file ("d:\1\файл.txt");

if (file.is_open()) // виклик методу is_open()
cout << "Всі ОК! Файл відкритий! \ n \ n" << endl;
else
{
cout << "Файл не відкритий! \ n \ n" << endl;
return -1;
}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

#include <iostream>
#include <fstream>
using namespace std;
 
int main()
{
 setlocale(LC_ALL, "rus");
 
 ifstream file ("d:\1\файл.txt");
 
 if (file.is_open()) // виклик методу is_open()
 cout << "Всі ОК! Файл відкритий! \ n \ n" << endl;
 else
 {
 cout << "Файл не відкритий! \ n \ n" << endl;
 return -1;
 }
}

Метод is_open() поверне 1, якщо файл знайдений та успішно відкритий. Інакше поверне 0 і спрацює код, прописаний в блоці else.

Якщо файл не відкритий, бажано обробити помилку. Як правило, якщо вся робота програми пов'язана з файлом пишуть повідомлення в консоль, і ставлять вихід із програми. При серйозних помилках прийнято повертати код виконання (число), який характеризувати ту чи іншу помилку. Коди для кожного виду помилок автор програми може вигадувати свої. Один із способів обробки помилок у програмі ми розглядали у статті Винятки у С++.

Якщо файл успішно відкритий, з нього можна читати.