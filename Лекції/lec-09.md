# Покажчики у С++

## Перелік лекцій


1.  [Склад мови С++](lec-01.md)
2.  [Типи даних та операції](lec-02.md)
3.  [Умовні оператори. Оператор вибору](lec-03.md)
4.  [Оператори циклів.](lec-04.md)
5.  [Масиви у С++](lec-05.md)
6.  [Дані символьного типу. Рядки](lec-06.md)
7.  [Функції. Бібліотеки функцій](lec-07.md)
8.  [Дані типу структура](lec-08.md)
9.  [Покажчики у С++](lec-09.md)
10. [Робота з динамічною пам'ятю](lec-10.md)
11. [Робота з файлами](lec-11.md)
12. [Обробка файлів за допомогою WinAPI32](lec-12.md)
13. [ООП. Класи та об'єкти. Члени класів](lec-13.md)
14. [ООП. Наслідування. Перевантаження операторів](lec-14.md)
15. [Паралельні обчислення за стандартом OpenMP](lec-15.md)
16. [Паралельні обчислення з бібліотекою MPI](lec-16.md)

## Покажчики та масиви


Покажчики — це змінні, котрі містять адресу пам’яті, розподіленої для об’єкта відповідного типу. Усі змінні, розглянуті до цього, зберігали якісь значення (дані). Ці дані могли бути різних типів: символьного, цілого, дійсного тощо. При оголошенні змінної-покажчика слід вказати тип даних, адресу яких буде містити змінна, та ім’я покажчика з символом «\*».



Загальний формат опису покажчика має вигляд:


`<тип> *<ім’я>;`



де тип — тип значень, на який вказує покажчик;
ім’я — ім’я змінної-покажчика;
«\*» — операція над типом, що читається «покажчик на тип».



Наприклад:


```cpp
int *рn; // покажчик на ціле значення;
float *pf1, *pf2; // два покажчики на дійсні значення.
```




Покажчики не прив’язують дані до якого-небудь визначеного імені змінної і можуть містити адреси будь-якого неіменованого значення. Існує адресна константа NULL, що означає порожню адресу.



Слід нагадати, що мова C++ налічує лише дві операції, які стосуються адрес змінних, а саме:



«&» — операція взяття адреси («адреса значення»);



«\*» — операція розіменування («значення за адресою»).



Операція взяття адреси «&» застосовується разом зі змінною і повертає адресу цієї змінної. Операція розіменування «\*» використовується разом з покажчиками і вилучає значення, на яке вказує змінна-покажчик, розташована безпосередньо після символа «\*».



Оголошення покажчиків можна здійснити одним з таких способів:


`
<тип> *ptr;
<тип> *ptr = <змінна-покажчик>;
<тип> *ptr = &<ім’я змінної>;
`


Наприклад:
`int *ptx, b; float у;` — оголошені змінна-покажчик ptx та змінні b і у;



`float *sp = &у;` — покажчику sp присвоюється адреса змінної у;



`float *р = sp;` — покажчику р присвоюється значення (адреса значення), яке міститься в змінній sp, тобто адреса змінної у.



При оголошенні покажчиків символ «\*» може знаходитися перед ім’ям покажчика або відразу після оголошення типу покажчика і поширювати свою дію тільки на одну змінну-покажчик, перед якою він записаний:



`long *pt; long *Uk; int *ki, x, h;` — оголошення описів.



За потреби для опису покажчика на комірку довільного типу замість ідентифікатора типу записується слово void, а саме:



`void *р, *pt;` — опис двох покажчиків на довільний тип даних.



Перед використанням покажчика у програмі його обов'язково необхідно ініціювати, іншими словами, необхідно присвоїти адресу якого-небудь даного, інакше можуть бути непередбачені результати.



Для одержання доступу до значення змінної, адреса якої зберігається в покажчику, досить у відповідному операторі програми записати ім’я покажчика з символом «\*» — здійснити операцію розіменування.



Розглянемо фрагмент програми з поясненнями:



`int *р, *р1;` — оголошені два покажчики на комірку пам’яті типу int;



`int х = 12, у = 5, m[7];` — оголошені змінні х, у і масив m, змінні ініційовані;



`р = &у;      // р (&у);` — покажчику р присвоєна адреса змінної у.



Якщо для цього фрагмента програми записати оператор виведення у вигляді



`cout << "Адрес р " << р << "Значение по этому адресу = " << *р;`,



то виведеться адреса комірки пам’яті, де записана змінна у і значення цієї змінної (тобто 5).



Використовуючи запис `х = *р;`, одержимо `х = 5`, тому щo `*р = у = 5;`.



Змінити величину параметра у можна так:


```cpp
у = 10; // *Р= 10;
*р = *р+5; //у +=5;
```

Остання операція означає збільшення значення змінної у цiлого типу на 5, тобто у= 15.



При ініціюванні покажчиків їм можна присвоювати або адресу об’єкта (змінної), або адресу конкретного місця пам’яті (масиву), або число 0 (нуль), а саме:


```cpp
int *pt = (char *) 0x00147; // — присвоюється адреса комірки;
int *arrpt = new int[10]; // — визначається початкова адреса розміщення динамічного масиву;
char *р = 0; // — здійснюється ініціювання нулем.
```




Оскільки покажчики — це спеціальні змінні, то в операціях з іншими покажчиками вони можуть використовуватися без символа «\*», тобто без розкриття посилання, наприклад:


```cpp
float *pt1, *pt2, х=15, m[5];
pt1 = &x; 
pt2 = pt1;
pt1 = m;         //pt1 = &m[0];
```

де  m — ім’я масиву, що розглядається як спеціальний покажчик-константа.



Приклад 6.6. Написати ілюстраційну програму з використанням покажчиків.


```cpp
// P6_6.CPP — применение указателей 
#include <iostream.h>
#include <conio.h>
int main ( )
{ int x = 10;
  int *px (&x);   // int *px = &x;
cout << "x =" << x << endl; 
  cout << "*px =" << *px << endl;
  x *= 2;          //x=x*2;
  cout << "Новое значение *px = " << *px << endl;*
  px += 2;       // *px=*px + 2;
  cout << "Результат *px, т. e. x = " << x << endl;
  getch();     //задержка экрана
}
```




Результат виконання програми:

```cpp
х = 10 
*рх = 10
```
```
Новое значение *рх = 20 
Результат *рх, т. е. х = 22
```




Для змінної-покажчика існує своя адреса і тому будуть до цільними записи:



`int *pt1, *pt2;`



`pt1 = (int*) &pt2;` — покажчику pt1 присвоюється адреса пам'ятi де розташована змінна pt2.



Це має сенс у випадку, коли


```cpp
int у, *pt1, *pt2 = &у;
pt1 = (int*) &pt2;
```




Обмеження на застосування операції взяття адреси:



* не можна визначати адресу літеральної константи (оскільки для неї не виділяється комірка пам’яті), тобто такий запис, як vp = &345; — неприпустимий;
* не можна визначати адресу результату арифметичного виразу, тобто запис vp = &(x + y); теж неприпустимий.


Дозволені операції для змінних-покажчиків:



* операція розіменування «\*»;
* операція взяття адреси «&»;
* операція присвоювання «=»;
* операції інкремент «++» і декремент «--»;
* операції додавання «+» і віднімання «-»;
* операції відношення (порівняння) покажчиків однакового типу: «==», «!=», «<», «<=», «>», «>=».


У мові C++ масиви і покажчики зв’язані між собою: ім’я масиву визначається як покажчик-константа на початковий (нульовий)елемент масиву. Так, наприклад, при оголошенні одновимірного масиву у вигляді int mas[20]; його ім’я mas - покажчик на адресу початкового елемента масиву &mas[0].



Існує два способи доступу до елементів масиву:



* з використанням індексу елемента масиву, наприклад, mas[2] або mas[i];
* з використанням адресного виразу, тобто виразу з покажчиком на масив, наприклад, `*(mas + 2)` або `*(mas + і)`.


Ім’я покажчика на масив можна записати так:


```cpp
int mas[20];
int *ptr1;
ptr1 = mas;      //ptr1 = &mas[0];
```
, тут вирази `&mas[0]` і `mas` — еквівалентні.



Оскільки в комп’ютері для масивів завжди є суцільний блок комірок пам’яті, в яких розташовуються їх елементи, то адресу наступного елемента mas[1] можна вказати шляхом збільшення покажчика на 1, а саме:


```cpp
р = &mas[0];
р++;   //р=р + 1;
```




Таким чином, адреса і-го елемента визначається як р + і. При цьому з урахуванням типу масиву і відведеної кількості байтів для кожного його елемента автоматично виконується операція збiльшення адреси, тобто:



`адреса х[і] = адреса х[0] + i*sizeof (тип);` .



Слід зауважити, що для покажчиків, які посилаються на елементи масивів різних типів, результат арифметичних операцій і операцій відношення невизначений.



До двох покажчиків р1 і р2, що вказують на елементи одного масиву, застосовують операції відношення: «==», «!=», «<», «<=», «>», «>=». При цьому значення покажчиків розглядаються як цілі числа, а результат порівняння дорівнює 0 ( »неправда») або 1 («істина»). Так, відношення вигляду р1<р2 є «істина», якщо р1 указує на більш ранній елемент, ніж р2. Будь-який покажчик можна порівняти з нулем.



В арифметиці з покажчиками можна використовувати адресу неіснуючого «наступного за масивом» елемента. До покажчиків можна додавати або віднімати від них цілу величину.



В обох випадках результатом операції буде покажчик на вихідний тип, значення якого на вказане число елементів більше або менше вихідного. Тобто, якщо до покажчика р можна додати деяку цілу величину n, а саме: р + n, то цей вираз визначає ділянку об’єкта, що займає n-не місце після об’єкта, на який вказує р, при цьому n автоматично збільшується на коефіцієнт, що дорівнює відповідній довжині об’єкта. Наприклад, якщо int займає 4 байти, то цей коефіцієнт дорівнює чотирьом.



Допускається також операція віднімання покажчиків, що вказують на елементи одного масиву. Так, якщо р1 < р2, то р2 - р1 + 1 — це число елементів масиву від р1 до р2 включно.



Наведемо приклади програм роботи з покажчиками.
Приклад 6.7. Обчислити середнє значення додатних елементів одновимірного масиву.



Розглянемо перший варіант програмної реалізації цієї задачі (див. Р6_7_1.СРР).


```cpp
/* Р671.СРР — вычисление среднего значения положительных элементов массива */
//---------------- программа без использования указателей
#include <iostream.h>
#include <conio.h>
main( )
{ const int n = 10;
  float mas[n], s = 0;
  int i, kol = 0;
  cout << "Ввод массива " << endl;
  for(i =0; і < n; i++)
    cin >> mas[i]; 
      for(i = 0; і < n; i++)   
        if (mas[i] > 0)  
{ s += mas[i];           //накопление суммы
          kol++;  //подсчет положительных елементов
        }
 cout.precision(3 ) ; 
  cout << "Средн. арифм. полож. элементов = " << s/kol << endl; 
 getch();         //задержка экрана вывода резулътата
}
```




Результати виконання програми:


Ввод массива
1.56 -4.78 6.5 7.89 -3.6 9.45 7.4 -8.43 9.3 -10.2
Средн. арифм. полож. элементов = 7.02



Використовуючи ім’я масиву як покажчик на початок масиву (перший елемент), можна навести другий варіант програми (див. Р6_7_2.СРР):


```cpp
// Р6_7_2.СРР - использование имени массива как указателя
#indude <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;  
  float mas[n], s;  
  int i, kol = 0;
  for (і = 0, s = 0; і < n; i++)
  { сіn >> *(mas+i);
    if (*(mas+i) > 0)
     { s += *(mas+i);
       kol++; }  
  } 
  cout.precision(3); 
  cout <<"\n Среднее арифм. полож. элементов = " << s/kol << endl; 
  getch();
}
```




Якщо описати покажчик і зв’язати його з масивом (адресувати на початок масиву), то з використанням арифметики покажчиків можна написати третій варіант (див. Р6__7_З.СРР) цiєї програми.


```cpp
// Р6_7_3. СРР — использование арифметики указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;
  int і, kol(0);
  float mas[n], s(0);
  float *pm = mas;         //pm= &mas[0];
for (і = 0; і < n; i++)  
  { cout << "Введите" << і << "элемент mas" << endl;
    cin >> *pm++;
    cout << mas[i] << endl;
    if (mas[i] >0) 
    { s += mas[i]; 
      kol++; }  
  }
  cout.precision(3);
  cout << "\n Среднее арифм. полож. элементов = " << s/kol << endl;
  getch();
}
```




У цій програмі для введення масиву застосований покажчик `*рm`, а для роботи з масивом — ім’я масиву з індексом.



В останньому випадку використання покажчика `*рm` призвело б до помилкового результату, оскільки цей покажчик в операціях введення збільшує свою адресу (рm++) після введення чергового елемента масиву і надалі вказує на ще не введений елемент.


Наведемо четвертий варіант (Р6_7_4.СРР) програмної реалiзації прикладу:


```cpp
// Р6_7_4.СРР — использование указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ const int n = 10;
  float mas[n], s = 0;
  float *pm = &mas[0];     //pm *= &mas[0];
 int i, kol = 0;
  for (і = 0; і < n; i++)
  { cout << "Введите" << і << "элемент mas" << endl;
    cin >> *pm; 
    if (*pm >0)
    { s += *pm; 
      kol++; 
      pm++; }  
  }
  cout.precision(3);
  cout << "\n Среднее арифм. полож. элементов = " << s/kol << endl;
 getch();
}
```




## Масиви покажчиків


Подібно до інших змінних, покажчики можна групувати в масиви, кожен з елементів яких містить адресу рядка масиву даних у пам’яті. Такий спосіб дозволяє зберігати дані з рваними краями, наприклад, деяку текстову інформацію (див. рис. 6.5) Масив з «рваними» краями схожий на двовимірну таблицю, рядки якої можуть мати різну довжину. Використання масиву покажчиків (`char *fio[]`) для збереження рядків дозволяє заощаджувати пам’ять, а процес обробки рядків виконується значно швидше, бо змінюються тільки покажчики, а не вміст рядків.



Приклад 6.8. Заданий масив з рваними краями (див. рис. 6.5) Навести програмну реалізацію виведення такої інформації з використанням масиву покажчиків.
[|IMG|](/uploads/posts/2015-12/1450816903_6_3.png)


```cpp
// P6_8.CPP — использование массива указателей
#include <iostream.h>
#include <conio.h>
main ( )
{ char *fio[ ] = { "Петренко",
                   "Головко",
                   "Корж",
                   "Куц",
                   "Юшко",
                   "Плющ" };    // инициализация массива указателей
 int str;
  for (str = 0; str <=5; str++)
  cout << " stroka " << (str + 1) << " = " << *(fio + str) << endl;
  getch();        // для задержки экрана вывода результата
}
```




Результати виконання програми:

```
stroka 1 = Петренко
stroka 2 = Головко
stroka 3 = Корж
stroka 4 = Куц
stroka 5 = Юшко
stroka 6 = Плющ
```



Нa рис. 6.5 представлено зв’язок масиву покажчиків char `*fio[]` з відповідними текстовими рядками.



Особливістю масиву покажчиків є те, що кожний з його елементів може вказувати на масив довільної довжини. Iснуе можливість записати двовимірний масив чисел і як матрицю, і як одновимірний масив покажчиків.



`int matr[5][7];`
 або
`int *pmt[5];`



При цьому двовимірний масив розглядається як одновимірний масив рядків, кожен елемент якого — це теж масив стовпцiв, тобто масивмасивів, тому індексування елементів матриці записуется у вигляді `mas[i][j]`.



Звернення до елемента `mas[i][j]` може здійснюватися так:



`*(pm[i] +j)`
          або
`*(*(рm + і) + j) `.



Приклад 6.9. Сформувати матрицю цілих чисел С(5,5), елементи якої обчислюються за формулою Сij = i+j. Підрахувати добуток елементiв, розташованих нижче побічної діагоналі, та обнулити ці елементи. Вивести на екран елементи, розташовані в трикутниках нижче головної та вище побічної діагоналей.



Перший варіант програмної реалізації даної задачі (див. Р6_10_1.СРР) передбачає, що матриця описується явним способом і робота ведеться з її елементами.


```cpp
// Р6_9_1.СРР — программа без использования указателей
#include <iostream.h>
#include <conio.h>
const int n = 5;
int main()
{ int i, j, C[n][n];
  int Pr;          // Pr —     переменная для подсчета произведения
//------------------- формирование матрицы С[n][n]
 cout << "------ Матрица С[n][n]: \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
   { C[i][j]=i+j;
     cout << C[i][j] << " " ;
   } 
   cout << endl;
 }
/* вычисление произведения (Pr) элементов ниже побочной диагонали и их последующее обнуление */
  Pr = 1;       //начальное значение Рr
 for (і = 0; і < n; i++)
    for (j = n - і; j < n; j++)
    { Pr*= C[i][j];
      C[i][j] = 0; }
//-------------- вывод па экран полученных результатов
  cout << "\n Произведение ниже побочной диагон. = " <<Рг << endl;
  cout << "\n-------- Преобразованная матрица \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
    cout << C[i][j] << " ";
    cout << endl; }
//---------------------- вывод элементов ниже главной диагонали
  cout << "\n Элементы ниже главной диагонали ";
  for (і = 0; і < n; i++)
  { for (j=0; j<n; j++)
    if (j < i) cout << C[i][j] << " ";
    else cout << " " ;
    cout << endl;  }
//--------------------- вывод элементов выше побочной диагонали
  cout << "\n Элементы выше побочной диагонали \n";
  for (і = 0; і < n; i++)
  { for (j = 0; j < n; j++)
    if (j < n-1-i) cout << C[i][j] << " ";
    else cout << " ";
    cout << endl; }
   getch();
   return 0;
}
```




Результати обчислень:

```
---Матрица C[n]|n]:
0 1 2 3 4
1 2 3 4 5
2 3 4 5 6
3 4 5 6 7
4 5 6 7 8
Произведение ниже побочной диагон. = 52920000
--- Преобразованная матрица
0 1 2 3 4
1 2 3 4 0
2 3 4 0 0
3 4 0 0 0
0 0 0 0 0
Элементы ниже главной диагонали
1
2 3
3 4 0
4 0 0 0
Элементы выше побочной диагонали
0 1 2 3
1 2 3
2 3
3
```




Другий варіант програмної реалізації (див. Р6_9_2.СРР) використовує масив покажчиків:


```cpp
// Р6_9_2.СРР — формирование и обработка матрицы
//-------------- используется массив указателей
#include <iostream.h>
#include <conio.h>
const int n = 5;
int main()
{ int i, j, Pr, C[n][n], *pm[n];
//---------------- инициализация массива указателей
  for (і = 0; і < n; і++)
  pm[i] = &C[i][0];
//--------------- формирование матрицы С[n][n]
  cout << " Матрица C[n][n]"<< endl;
  for (i = 0; і < n; i++)
    for(j = 0; j < n; j++) 
    *(pm[i] + j) = i+j;
//------------------ вывод матрицы
 for (i = 0; i < n; i++)
  { for (j = 0; j < n; j++)
    cout << *(pm[i] + j) << " ";
cout << endl; }
/* вычисление произведения (Pr) элементов ниже побочной диагонали и их последующее обнуление */
 Pr = 1;
  for (i = 0; i < n; i++)
    for (j = n-i; j < n; j++)
    { Pr*=*(pm[i] + j);
      *(pm[i]+j) = 0; }
//------------ вывод на экран полученных результатов
 cout << endl <<" Произведение ниже побочной диагон. = " << Pr << endl;
  cout << endl << " Преобразованная матрица " << endl;
  for (і = 0; і < n; i++)
    { for (j = 0; j < n; j++) 
      cout << *(pm[i] + j) << " ";
      cout << endl; }
//----------------- вывод элементов ниже главной диагонали
cout << endl << " Элементы ниже главной диагонали"; 
  for (і=0; і < n; і++)  
  { for (j = 0; j < n; j++)
    if (j < i) cout << *(pm[i] + j) << ' ';
    else cout << " ";
    cout << endl;}
  cout << endl;
//------------ вывод элементов выше побочной диагонали
  cout << endl << " Элементы выше побочной диагонали " << endl;
  for (і = 0; і < n; і++)  
  { for (j = 0; j < n; j++)
    if (j < n-1-i) cout << *(pm[i] +j) << ' ';
    else cout << " ";
    cout << endl; }
   getch();
  return 0;
}
```




У розглянутій програмі для виведення матриці можна використати інший вигляд оператора виведення, наприклад:
`cout << ( (j == 0) ? '\t': ' ')<< *(pm[i] +j) << ((j==n)? '\n':' ');`.



Ім'я двовимірної матриці є покажчиком-константою на масив покажчиків-констант, кожний з елементів якого вказуе на початок відповідного рядка матриці. Наприклад, для матриці `mat[2][2]` маємо:
`mat[0]` — покажчик-константа на нульовий рядок матриці;
`mat[1]` — покажчик-константа на перший рядок матриці;
`mat[2]` — покажчик-константа на другий рядок матриці;,
тобто:
`mat[0] == &mat[0][0];`
`mat[1] == &mat[1][0];`
`mat[2] == &mat[2][0];`.
Виведення матриці можна реалізувати з використанням одного з наведених нижче операторів, наприклад:
* `cout << mat[i][j];`
* `cout << *(mat[і] + j);`
* `cout << *(*(mat + і) + j);.`
Приклад 6.10. Задана матриця aij (i = 1...n, j = 1...m) n = 3, m = 4, необхідно її парні елементи переписати до масиву b, а непарні — до масиву с.



Алгоритм розв’язання цієї задачі наведено у прикладі 1.6


```cpp
/* Р6_10.СРР — формирование массивов четных и нечетных элементов */
// использование имени массива как указателя на его начало
#include <iostream.h>
#include <conio.h>
const int n = 3, m = 4;
void main ()
{ int a[n][m], b[m*n], c[m*n], i, j, kc = 0, kn = 0;
// kc и kn — счетчики подсчета четных и нечетних элементов
//-------------------- ввод исходной матрицы а[n][m]
  cout << " Vvod massiva a[n][m] " << endl;
  for (і = 0; і < n; i++)
    for (j = 0; j < m; j++)
    cin >> *(*(a+i)+j);
//------------ формирование массивов b[ ] и c[ ]
for (i = 0; і < n; i++)
    for (j = 0; j < m; j++)
    if (*(*(a+i)+j)%2 == 0) *(b+kc++) = *(*(a+i)+j);
    else *(c+kn++) = *(*(a+i)+j);
//—-------- вывод массива b[] — четных элементов
  cout << endl << "massiv chetn. elementov — b[ ] " << endl;
  for (і = 0; і < kc; i++) 
  cout << *(b+i) << " ";
  cout << endl;
//----------------- вывод массива c[ ] — нечетных элементов
cout << endl << "massiv nechetn. elementov — c[ ]" << endl;
  for (і = 0; і < kn; i++)
  cout << *(c+i) << " ";
  cout << endl;
//------------------  вывод исходной матрицы a[n][m] в естественном  виде
 cout << endl << "ishodny massiv";
  for (і = 0; і < n; і++)
  { cout << endl;
    for (j = 0; j < m; j++)
    cout << *(*(a+i)+j) << " "; }
   getch();
}
```




Результати обчислень:

```
Vvod massiva a[n][m]
8 2 4 -1
6 1 0 -5
2 9 3 -1
massiv chetn. elementov — b[] 
8 2 4 6 0 2
massiv nechetn. elementov — c[] 
-1 1 -5 9 3 -1
ishodny massiv
8 2 4 -1
6 1 0 -5
2 9 3 -1
```




У C++ можна описати змінну, що має тип «покажчик на покажчик». Ознакою такого типу є повторення символа «\*» при описі змінної, тобто int pmt;.



Пам’ять для такої змінної не виділяється. Її треба привести до відповідного масиву. При описі покажчик на іпокажчик можна ініціювати:

```cpp
int х = 20;
int *px1 = &х;
int рх2 = &рх1;
int *рхЗ = &рх2;
```

Доступ до змінної х здійснюється одним з трьох, способів:
`*рх1`;
`px2`;
`*рхЗ`;.



Для доступу до пам’яті через покажчики на покажчики використовуються як символи «\*», так і індекси. Наприклад, іеквівалентими будуть такі посилання на змінну х:


`*px1;               //рx1[0];`
`рх2;             //рх2[0][0];`
`*рхЗ;           //рхЗ[0][0][0];`.








