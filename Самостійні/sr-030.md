ОРГАНІЗАЦІЯ ВВЕДЕННЯ-ВИВЕДЕННЯ ДАНИХ
====================================

Потокове введення-виведення
---------------------------

У мові C++ дії, що пов'язані з операціями введення і виведення, виконуються за допомогою функцій бібліотек. Функції ведення і виведення бібліотек мови дозволяють читати дані з файлів та пристроїв і писати дані у файли і на пристрої.

Бібліотека мови C++ підтримує три рівня введення-виведення даних:

* введення-виведення потоку;
* введення-виведення нижнього рівня;
* введення-виведення для консолі і порту.

При введенні-виведенні потоку всі дані розглядаються як потік окремих байтів. Для користувача потік — це файл на диску або фізичний пристрій, наприклад, дисплей чи клавіатура, або пристрій для друку, з якого чи на який направляється потік даних. Операції введення-виведення для потоку дозволяють обробляти дані різних розмірів і форматів від одиночного символу до великих структур даних. Програміст може використовувати функції бібліотеки, розробляти власні і включати їх у бібліотеку. Для доступу до бібліотеки цих класів треба включити в програму відповідні заголовні файли.

За замовчуванням стандартні введення і виведення повідомлень про помилки відносяться до консолі користувача (клавіатури та екрана). Це означає, що завжди, коли програма очікує введення зі стандартного потоку, дані повинні надходити з клавіатури, а якщо програма виводить дані — то на екран.

У мові C++ існує декілька бібліотек, які містять засоби введення-виведення, наприклад:**stdio.h, iostream.h.** Найчастіше застосовують потокове введення-виведення даних, операції якого включені до складу класів **istream** або **iostream**. Доступ до бібліотеки цих класів здійснюється за допомогою використання у програмі директиви компілятора **#include `<iostream.h>`**.

**Для потокового введення даних** вказується операція «**>>**» («читати з»). Це перевантажена операція, визначена для всіх простих типів і покажчика на **char**. Стандартним потоком введення є **cin**.

Формат запису операції введення має вигляд:

**сin \[>> values\];** 

де **values** — змінна.

Так, для введення значень змінних **х і у** можна записати:

сin >> х >> у;
	

Кожна операція «>>» передбачає введення одного значення. При такому введенні даних необхідно дотримуватись конкретних вимог:

* для послідовного введення декількох чисел їх слід розділяти символом пропуску (« ») або **Enter** (дані типу **char** роздiляти пропуском необов'язково);
* якщо послідовно вводиться символ і число (або навпаки), пропуск треба записувати тільки в тому випадку, коли символ (типу **char**) є цифрою;
* потік введення ігнорує пропуски;
* для введення великої кількості даних одним оператором їх можна розташовувати в декількох рядках (використовуючи Enter);
* операція введення з потоку припиняє свою роботу тоді, коли всі включені до нього змінні одержують значення. Наприклад, для операції введення **х і у**, що вказана вище, можна ввести значення **х та у** таким чином:

2.345 789 (Enter)
або   
2.345 (Enter)
789 (Enter)
		

Оскільки в цьому прикладі пропуск є роздільником між значеннями, що вводяться, то при введенні рядків, котрі мiстять пропуски у своєму складі, цей оператор не використовується. У такому випадку треба застосовувати функції **getline(), get()** тощо. У мові C++ бажано здійснювати потокові введення-виведення даних.

Для потокового виведення даних необхідна операція **«<<»** («записати в»), що використовується разом з ім'ям вихідного потоку **cout**. Наприклад, вираз

cout << х;
		

означає виведення значення змінної **х** (або запис у потік). Ця операція вибирає необхідну функцію перетворення даних у потік байтів.

Формат запису операції виведення представляється як: `cout << data [<< data1];`

де **data, data1** — це змінні, константи, вирази тощо.

Потокова операція виведення може мати вигляд: `cout << "у =” << x + а – sin(x) << "\n";.`

Застосовуючи логічні операції, вирази треба брати в дужки: `cout << "р =" << (а && b || с) << "\n";.`

Символ переведення на наступний рядок записується як рядкова константа, тобто `"\n"`, інакше він розглядається не як символ керуючої послідовності, а як число 10 (код символу). Таких помилок можна уникнути шляхом присвоювання значення керуючих символів змінним, тобто:

#define << sp " "
#define << ht "\\t"
#define << hl "\\n".
		

Тепер операцію виведення можна здійснити так: **cout << "у =" << x + а – sin(x)<< hl;** .

Слід пам'ятати, що при виведенні даних з використанням «cout <<» не виконується автоматичний перехід на наступний рядок, для реалізації такого переходу застосовується так переведення рядка "\\n" або операція endl. Тобто, вивести рядкову константу можна, наприклад, так:

cout << "О деле суди по исходу \\n";
		

або   cout << "О деле суди по исходу" << endl;.
		

Приклад 4.1. Написати програму, що містить організацію виведення даних, пояснювальні повідомлення, а також символи переведения рядка.

```cpp
/* Р4_1.СРР — печать значений переменных с соответствующими пометками */
#include <iostream.h>
#include <conio.h>
int main()
{
	char first = 'W';
	char middle = 'P';
	char last = 'S'; 
	int wozrast = 20; 
	int doplata = 2;
	float zarplata = 309.75; 
	float prozent = 8.5;
	// вывод результатов
	cout << "Проверка исходных данных\\n";
	cout << first << middle << last << "\\n\\n";
	cout << "Возраст доплата зарплата процент:\\n";
	cout << " " << wozrast << " " << doplata << " " << zarplata << " " << prozent;
	getch ();
}
```

		

В останніх двох операціях виведеня програми можна використати символи табуляції. Наприклад, **«\\t»** поміщає кожне наступне ім'я або число в наступну позицію табуляції (через вісім символів), у цьому випадку маємо:

cout << "Возраст \\t доплата\\t зарплата\\t процент\\t \\n";<
cout << wozrast << "\\t" << doplata << "\\t" << zarplata << "\\t" << prozent << "\\n";
		

Для додаткового керування даними, що виводяться, використовують маніпулятори **setw(w)** та **setprecision(d)**. Маніпулятор **setw(w)**призначений для зазначення довжини поля, що виділяється для виведення даних (**w** — кількість позицій). Маніпулятор **setprecision(d)** визначає кількість позицій у дробовій частині дійсних чисел.

Маніпулятори змінюють вигляд деяких змінних в об'єкті **cout**, що у потоці розташовані за ними. Ці маніпулятори називають прапорцями стану. Коли об'єкт посилає дані на екран, він перевіряє прапорці, щоб довідатися, як виконати завдання, наприклад, запис:

`cout << 456 << 789 << 123;`

призводить до виведення значення у вигляді: **456789123**, що ускладнює визначення групи значень.

**Приклад 4.2.** Написати програму, використовуючи маніпулятор **setw()**.

```cpp
// P4J2.CPP — использование манипулятора setw()
#include <iostream.h>
#include <iomanip.h>
#include <conio.h>
main ( )
{
	cout << 456 << 789 << 123 << endl;
	cout << setw(5) << 456 << setw(5) << 789 << setw(5) << 123 << endl;
	cout << setw(7) << 456 << setw(7) << 789 << setw(7) << 123 << endl;
	getch ();
}
```

Результати виконання програми:

456789123 
456     789     123 
456       789       123
		

У цьому прикладі з'явився новий заголовний файл **iomanip.h**, що дозволяє застосовувати функції маніпуляторів. При використанні функції **setw()** число вирівнюється вправо в межах заданої ширини поля виведення. Якщо ширина недостатня, то вказане значення ігнорується.

Функція **setprecision(2)** повідомляє про те, що число з плаваючою крапкою виводиться з двома знаками після крапки з округленням дробової частини, наприклад, при виконанні операції

**cout << setw(7) << setprecision(2) << 123.456789;**

буде отримано такий результат: **123.46.**

Функції **cout.width(w)** та **cout.precision(d)**, які потребують підключення тільки заголовного файла **iostream.h**, виконують дії, подібні тим, що і функції **setw(w)** та **setprecision(d)**.

Операція введення використовує ті ж самі маніпулятори, що й операція виведення. Список змінних, в які будуть поміщені дані, визначений у **values**.

**Приклад 4.3.** Написати програму обчислення податку на продаж.

```cpp
// Р4_З.СРР — вычисление налога на продажи 
// использование манипулятора setprecision()
#include <iostream.h>
#include <iomanip.h>
#include <conio.h>
main ( )
{ float prod\_sum; // prod\_sum — сумма продаж
	float nalog;
	//\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  вывод подсказки для пользователя
	cout << "Введите сумму продаж";
	cin >> prod_sum;
	//............... вычисление налога на продажу
	nalog = prod_sum* 0.7;
	cout << " " << setprecision(2) << prod_sum;
	cout << " " << setprecision(2) << nalog << "\\n";
	getch(); // задержка экрана
	return 0;
}
```

Унаслідок того, що у першому операторі **cout** відсутня інструкція переведення рядка, відповідь користувача на підказку (тобто введене значення змінної **prod_sum**) з'явиться відразу праворуч за самою підказкою.

Форматоване введення-виведення
------------------------------

Форматоване введення-виведення величин здійснюється з використанням функцій **scanf** та **printf**, які успадковані з мови С. Щоб зв'язати програму користувача зі стандартною бібліотекою, де знаходяться ці функції, необхідно на початку програми включити заголовний файл **stdio.h**.

**Функція scanf**, що забезпечує форматоване введення даних, має змінне число параметрів, при цьому перед відповідним параметром ставиться знак **«&»** — символ взяття адреси змінної. Наприклад, `&х1` означає адресу змінної **х1**, а не значення, яке ця змінна має в даний момент. Рядок форматів функції **scanf** вказує, які дані очікуються на вході. Якщо функція зустрічає у форматному рядку знак **« % »**, за яким розташований знак перетворення, то на вході будуть пропускатися символи, доки не з'явиться деякий непорожній символ.

Форма запису функції **scanf** має вигляд:

			scanf ("рядок форматних кодів", список імен змінних); 
		

Рядок форматних кодів являє собою таку структуру запису:

**%\[ \* \]\[довжина\]\[f|n\]\[h|l\] тип,**

де **«%»** — ознака початку форматного коду. Якщо за символом **«% »** йде символ, що не є символом керування форматом, то він розглядається як звичайна послідовність символів. При цьому наступні за ним символи (до наступного символу **«%»**) також вважаються просто символами; якщо за символом **«%»** йде символ **«\*»**, то присвоювання наступного вхідного поля приглушується, поле читається, але не зберігається;

**довжина** — позитивне десяткове ціле число, яке задає максимальне число символів, що може бути прочитане з вхідного потоку, доки не зустрінеться символ « » (пропуск) або символ, який не може бути перетворений відповідно до заданого формату;

**f | n** — дозволяють приглушити погодження за замовчуванням про використану модель пам'яті («далека», «близька» пам'ять);

**h | l** — предикати, що визначають відповідно аргументи типів **short і long**;

**тип** — задається одним із символів: **d** — десяткове ціле; **і** — десяткове, вісімкове чи шістнадцяткове ціле зі знаком; **с** — одиночний символ;**u** — беззнакове десяткове число; **х, X** — беззнакове шістнадцяткове число; **0** — вісімкове число; **s** — сприймає символи без перетворення до символу **«\\n»** або пропуску, доки не буде досягнута задана довжина (при виведенні видає до потоку всі символи до символу **«\\0»** або до досягнення специфікованої точності); **f, F** — значення з плаваючою крапкою; **е, Е** — значення у експоненціальній формі; **G, g** — значення зі знаком у формі **f** або **е**.

Аргументи у функції **scanf** мають бути записані у формі покажчиків, тобто у вигляді **&х, &у, &mas\[i\]** тощо. Для введення змінних **k** (типу **int**) і **р** (типу **float**) цю функцію можна записати так:

**scanf(" %d %f \\n ”, &k, &р);.**

**Приклад 4.4.** Ввести два числа та обчислити їх суму.
```cpp
// Р4 4.СРР — ввод двух чисел и вычисление их суммы
#include <stdio.h>
#include <conio.h>
main( )
{ int a, b, c; 
	scanf ( " %d  %d",&a,&b);     //ввод чисел 5 и 8
	с = a + b;
	printf ("Summa =%d \\n", c); 
	getch();      //задержка экрана
}
```		

У результаті виконання програми буде виведено: **Summa=13**.

Форматний рядок наказує функції **scanf** ввести десяткове число, яке треба помістити в змінну **а**, а потім перейти до наступного не порожнього символу і з цього моменту почати введення нового десяткового числа, яке потім присвоюється змінній **b**. Якщо за рядком керування форматом аргументів більше, ніж специфікацій формату, зайві аргументи ігноруються. Коли для специфікацій формату недостатньо аргументів, результат не визначений.

У наведеному фрагменті програми для форматованого виведення даних використовується функція **printf**.

**Функція printf** може використовуватися, наприклад, для виведення повідомлення на екран:

**printf ("Введите исходные данные \\n");**

Для звертання до функції використовуються параметри, якi розташовані у круглих дужках. Найчастіше функція **printf** реалізується для виведення значень змінних. Першим аргументом у звертанні до функції ставиться рядок форматів (береться в лапки), а наступними, якщо вони є, — об'єкти, що виводяться.

Рядок форматів може включати звичайні символи, які копіюються при виведенні, і специфікації перетворення, що починаються із символу«% », за специфікаціями йде символ перетворення. Кожна специфікація перетворення відповідає одному з аргументів, що йдуть за форматним рядком, і між ними встановлюється взаємно однозначна відповідність, наприклад:

`printf ("Значения а, Ь, с равны: %d %d. %d \n", а, b, с);,`

тут літера **d** у специфікації перетворення вказує, що значення аргументу має бути представлено як десяткове ціле число.

При виведенні функція **printf** використовує ті самі специфікації, що і функція **scanf** при введенні. Наприклад, у функції **printf** вигляду

`printf (" % с=%d \n", g, g);`

значення змінної **g** виводиться як символ алфавіту, а після знака «=» — як числове значення. Перед символом перетворення може стояти числовий коефіцієнт, що вказує кількість позицій у виведеному рядку, відведених для елемента виведення. Список форматних кодів має таку форму запису:

			% \[прапорець\] \[довжина\] \[точність\] \[f | n\] \[h | l\] тип ,
		

де **прапорець** — символ, що керує вирівнюванням виведення і виведенням пропусків, десяткової крапки, ознак чисел вісімкової і шістнадцяткової систем числення. **Прапорець** може задаватися одним із символів:

* **«-»** — вирівнювання вліво усередині заданого поля;
* **«+»** — виведення знака числа;
* **« »** (пропуск) — приєднання пропуску до виведеного числа, якщо число є додатним і має тип зі знаком;
* **«#»** — виводиться ідентифікатор системи числення для цілих: **0** — для вісімкових чисел, **0х** чи **0Х** — для шістнадцяткових чисел;

**довжина** — визначає мінімальну кількість виведених символiв, якщо довжина більше виведеної кількості символів, то виведене значення доповнюється пропусками, у випадку, коли довжина менше кількості символів у виведеному значенні або вона не задана, виводяться всі символи значення (відповідно до поля точність, якщо воно є);

**точність** — задається цілим числом після крапки і визначає кількість виведених символів, кількість знаків після крапки; на відміну від поля довжини поле точність може привести до «зрізання» виведених даних.

Параметри **f, n, h, l** і **тип** списку форматних кодів за змістом аналогічні раніше описаним для функції **scanf**.

Виведення результатів з використанням форматних кодів функції **printf** може мати вигляд:

printf (" % 3.0 f % 6.1 f \ n ”, х, у);
		

**Приклад 4.5.** Обчислити значення функції `у = ах2 – sinx`, якщо `а = 10,5; х є [-1; 2]; hx = 0,5`.

Алгоритм розв'язання поставленої задачі розглянуто у **прикладі 1.1**, а його програмна реалізація матиме такий вигляд:
```cpp
// Р45.СРР — использование форматных кодов при выводе
#include <stdio.h>
#include <math.h>
#include <conio.h> 
main( )
{ float x, y, a(10.5); 
	printf ("\\t Vivod rezultata\\n"); 
	for (x = -1; x <= 2; x += 0.5)
	{ у = a * pow(x,2) - sin(x);     //у = a\*x\*x - sin(x);
		printf (" \\t x = % 4.1f    у = % 6.3f \\n", x, y);
	}
	getch ();      //задержка экрана
}
```		

Результати обчислення:

Vivod rezultata
x = -1.0 у =11.342
х = -0.5 у = 3.104
х = 0.0  у = 0.000
х = 0.5  у = 2.146
х = 1.0  у = 9.659
х = 1.5  у = 22.628
х = 2.0  у = 41.091
		

Контрольні запитання
--------------------

1.  Як забезпечується організація введення даних на С++?
2.  Як здійснюється виведення результатів на С++?
3.  Як реалізується потокове введення даних «сіn>>»? Наведiть приклади.
4.  Охарактеризуйте основні аспекти використання потокового ви ведення даних «соut<<».
5.  Що таке форматоване введення-виведення даних?
6.  Поясніть правила застосування функції scanf.
7.  Як здійснює роботу функція printf?